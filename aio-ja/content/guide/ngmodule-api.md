# NgModule API

大まかにいうと、
NgModuleはAngularアプリケーションを整理する方法で、
`@NgModule`デコレーター内のメタデータを通して実現します。
メタデータは3つのカテゴリーに分類されます:

* **静的:** コンパイラーの設定。ディレクティブのセレクターと、テンプレート内のディレクティブがセレクターのマッチングを通してどれに適用すべきかをコンパイラーに知らせます。これは`declarations`配列によって設定されます。
* **ランタイム:** `providers`配列経由でのインジェクターの設定。
* **コンポーザビリティ/グルーピング:** `imports`、`exports`配列経由でNgModuleをまとめて、利用可能にします。

```typescript
@NgModule({
  // 静的な、つまりコンパイラーの設定です
  declarations: [], // セレクターを設定します
  entryComponents: [], // ホストファクトリーを生成します

  // ランタイム、あるいはインジェクターの設定
  providers: [], // ランタイムインジェクター設定

  // コンポーザビリティ / グルーピング
  imports: [], // NgModuleをまとめて組み込みます
  exports: [] // NgModuleをアプリケーションの他の部分で利用可能にします
})
```

## `@NgModule` メタデータ

次の表は`@NgModule`メタデータのプロパティをまとめたものです。

<table>

  <tr>

    <th>
      プロパティ
    </th>

    <th>
      説明
    </th>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>declarations</code>
    </td>

    <td>

      _このモジュールに属している_[宣言](guide/ngmodule-faq#q-declarable)クラス
      (*コンポーネント*、*ディレクティブ*、および*パイプ*)のリスト。

      <ol>
        <li>テンプレートをコンパイルするときは、対応するディレクティブを動作させるために使用するセレクターのセットを決定する必要があります。</li>
        <li>
          テンプレートは、テンプレートのコンポーネントが宣言されているNgModuleのコンテキスト内でコンパイルされます。セレクターのセットは次のルールで決定されます:
          <ul>
            <li><code>declarations</code>配列内のディレクティブのセレクターすべて</li>
            <li>インポートしたNgModuleがエクスポートしているディレクティブのセレクターすべて</li>
          </ul>
        </li>
      </ol>

      コンポーネント、ディレクティブ、およびパイプは、_厳密_に1つのモジュールに属している必要があります。
      複数のモジュールで同じクラスを宣言しようとすると、コンパイラでエラーが発生します。
      別のモジュールから直接的または間接的にインポートされたクラスを再宣言しないように注意してください。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>providers</code>
    </td>

    <td>

      依存性の注入のプロバイダーのリスト。

      AngularはこれらのプロバイダーをNgModuleのインジェクターに登録します。
      それがブートストラップに使用されているNgModuleの場合は、ルートインジェクターに登録されます。

      これらのサービスはこのインジェクターの子供である任意のコンポーネント、ディレクティブ、パイプ、またはサービスに注入できるようになります。

      遅延ロードしたモジュールは自身のインジェクターを持ち、
      それは通常はアプリケーションのルートインジェクターの子供です。

      遅延ロードしたサービスは遅延ロードしたモジュールのインジェクターのスコープで管理されます。
      遅延ロードしたモジュールが`UserService`を提供していた場合、
      そのモジュールのコンテキストで(たとえばルーターのナビゲーションによって)作成された任意のコンポーネントは、ルートインジェクター内のインスタンスではなく、
      サービスのローカルインスタンスを取得します。

      外部モジュール内のコンポーネントはそれぞれのインジェクターが提供するインスタンスを受け取り続けます。

      注入の階層やスコーピングの詳細については[プロバイダー](guide/providers)や[DIガイド](guide/dependency-injection)を参照してください。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>imports</code>
    </td>

    <td>

      このモジュールに畳み込まれるべきモジュールのリスト。
      畳み込むとは、すべてのインポートしたNgModuleがエクポートしているプロパティがあたかもここで宣言したかのようにするという意味です。

      具体的には、
      コンポーネント、ディレクティブ、またはパイプをエクスポートしているモジュールのリストが、このモジュールで宣言したかのようにコンポーネントのテンプレートから参照されます。

      コンポーネントのテンプレートが他のコンポーネント、ディレクティブ、およびパイプを[参照](guide/ngmodule-faq#q-template-reference)できるのは、
      その参照がこのモジュールで宣言されているか、もしくはインポートしたモジュールがエクスポートしているときです。
      たとえば、コンポーネントはモジュールがAngularの`CommonModule`をインポートするだけ(おそらく`BrowserModule`をインポートすることで間接的にインポートされます)で
      `NgIf`や`NgFor`ディレクティブを使用できます。

      多くの標準ディレクティブを`CommonModule`からインポートできます。
      しかし、いくつかのおなじみのディレクティブは他のモジュールに属しています。
      たとえば、
      Angularの`FormsModule`をインポートしたあとにのみ`[(ngModel)]`を使用できます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>exports</code>
    </td>

    <td>

      宣言(*コンポーネント*、*ディレクティブ*、および*パイプ*のクラス)のリスト。
      インポートするモジュールがこれを使用できます。

      エクスポートした宣言はモジュールの_公開API_となります。
      他のモジュール内のコンポーネントが、_この_モジュールの`UserComponent`を[使用](guide/ngmodule-faq#q-template-reference)できるのは、
      このモジュールをインポートし、かつ、このモジュールが`UserComponent`をエクスポートする場合です。

      宣言はデフォルトでは非公開です。
      このモジュールが`UserComponent`をエクスポート_しない_場合
      _この_モジュール内のコンポーネントだけが`UserComponent`を使用できます。

      モジュールをインポートしても、インポートしたモジュールのインポートを自動的に再エクスポート_しません_。
      モジュール'B'は、`CommonModule`をインポートするモジュール'A'をインポートしただけでは、`ngIf`を使用できません。
      モジュール'B'は`CommonModule`を自身でインポートする必要があります。

      モジュールは他のモジュールを自身の`exports`配列に追加できます。
      その場合、そのモジュールの公開のコンポーネント、ディレクティブ、およびパイプすべてがエクスポートされます。

      [再エクスポート](guide/ngmodule-faq#q-reexport)はモジュールの推移性を明示的にします。
      モジュール'A'が`CommonModule`を再エクスポートし、モジュール'B'がモジュール'A'をインポートする場合、
      モジュール'B'のコンポーネントは、'B'自身が`CommonModule`をインポートせずとも`ngIf`を使用できます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>bootstrap</code>
    </td>

    <td>

      自動でブートストラップされるコンポーネントのリスト。

      通常、このリストにはアプリケーションの _ルートコンポーネント_ 1つだけが配置されます

      Angularは複数のブートストラップコンポーネント
      (ホストウェブページ内のそれぞれ自身のコンポーネントが配置された場所)で起動できます。

      ブートストラップコンポーネントは自動的に`entryComponents`に追加されます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>entryComponents</code>
    </td>

    <td>

      ビューに動的にロードできるコンポーネントのリスト。

      デフォルトでは、Angularアプリケーションは常に少なくとも1つのエントリーコンポーネントを持ちます(ルートコンポーネントである`AppComponent`)。その目的はアプリケーションへのエントリーポイントとして機能することで、つまり、アプリケーションを起動するためにそれをブートストラップします。

      ルーテッドコンポーネントも動的にロードする必要があるため、_エントリーコンポーネント_になります。
      ルーターはそれを生成して、`<router-outlet>`付近のDOMに配置します。

      ブートストラップするコンポーネントとルーテッドコンポーネントは_エントリーコンポーネント_ですが、
      これは暗黙的に追加されるので
      `entryComponents`配列に追加する必要はありません。

      Angularはモジュールの`bootstrap`とルート定義内のコンポーネントを`entryComponents`配列に自動的に追加します。

      これでは、[`ViewComponentRef.createComponent()`](https://angular.io/api/core/ViewContainerRef#createComponent)のような命令的なテクニックのひとつを使ってブートストラップされるコンポーネントを検出できないままです。

      動的なコンポーネントのロードはルーター以外のほとんどのアプリケーションで一般的ではありません。動的にコンポーネントをロードしたい場合は、`entryComponents`配列に手動でコンポーネントを追加する必要があります。

      詳細については[エントリーコンポーネント](guide/entry-components)を参照してください。

    </td>

  </tr>

</table>


<hr />

## NgModuleの詳細

あなたはこちらにも興味があるかもしれません:
* [フィーチャーモジュール](guide/feature-modules)
* [エントリーコンポーネント](guide/entry-components)
* [プロバイダー](guide/providers)
* [フィーチャーモジュールの種類](guide/module-types)
