block includes
  include ../_util-fns
  - var _library_module = 'library module'
  - var _at_angular = '@angular'

:marked
  Angular is a framework for building client applications in HTML and
  either JavaScript or a language (like Dart or TypeScript) that compiles to JavaScript.

  Angular 2は、HTMLと、JavaScriptまたは（DartやTypeScriptのような）JavaScriptにコンパイルする言語で、
  クライアントアプリケーションを構築するためのフレームワークです。

block angular-parts
  :marked
    The framework consists of several libraries, some of them core and some optional.

    そのフレームワークはいくつかのライブラリから構成されており、それらには中心的なものと任意のものがあります。

:marked
  You write Angular applications by composing HTML *templates* with Angularized markup,
  writing *component* classes to manage those templates, adding application logic in *services*,
  and boxing components and services in *modules*.

  Angularアプリケーションの作成は、Angular化されたマークアップを使用したHTML*テンプレート*を作成し、
  それらのテンプレートを管理するための*コンポーネント*のクラスを書き、アプリケーションのロジックを*サービス*に追加し、
  コンポーネントとサービスを*モジュール*につめこむことによって行います。
  
  Then you launch the app by *bootstrapping* the _root module_.
  Angular takes over, presenting your application content in a browser and
  responding to user interactions according to the instructions you've provided.

  次に、_ルートモジュール_をブートストラップすることでアプリを起動します。
  そこからはAngularが引きついで、アプリケーションの内容をブラウザに表示し、そして与えられた指示に従ってユーザーの操作に応答します。

  Of course, there is more to it than this.
  You'll learn the details in the pages that follow. For now, focus on the big picture.

  もちろん、Angularにはこれ以上にもっと多くのものがあります。
  詳細はこのページの後の方で学ぶことになります。今のところは、全体像に集中しましょう。

figure
  img(src="/resources/images/devguide/architecture/overview2.png" alt="overview" style="margin-left:-40px;" width="700")

:marked
  The architecture diagram identifies the eight main building blocks of an Angular application:

  このアーキテクチャの図が、Angular 2アプリケーションの八つの主な基礎的要素を明確にしています。

  * [Modules](#modules)
  * [モジュール](#modules)
  * [Components](#components)
  * [コンポーネント](#components)
  * [Templates](#templates)
  * [テンプレート](#templates)
  * [Metadata](#metadata)
  * [メタデータ](#metadata)
  * [Data binding](#data-binding)
  * [データバインディング](#data-binding)
  * [Directives](#directives)
  * [ディレクティブ](#directives)
  * [Services](#services)
  * [サービス](#services)
  * [Dependency injection](#dependency-injection)
  * [依存性の注入](#dependency-injection)

  Learn these building blocks, and you're on your way.

  これらの基礎的要素を学んでから、あなたの道を進みましょう。

.l-sub-section
  p The code referenced on this page is available as a #[+liveExampleLink2()].
  p このページで参照されているコードは、#[+liveExampleLink2()]として入手できます.

.l-main-section
:marked
  ## Modules

  ## モジュール
figure
  img(src="/resources/images/devguide/architecture/module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )
:marked
  Angular apps are modular and Angular has its own modularity system called _Angular modules_ or _NgModules_.

  Angularアプリはモジュール別に構成できます。Angularには独自のモジュール性システムがあり、
  それは_Angularのモジュール_、または_NgModules_と呼ばれています。

  _Angular modules_ are a big deal. 
  This page introduces modules; the [Angular modules](ngmodule.html) page covers them in depth.

  _Angularのモジュール_は重要です。
  このページではモジュールを紹介して、その詳細は[Angularのモジュール](ngmodule.html)のページで扱います。

<br clear="all"><br>
:marked
  Every Angular app has at least one module, the _root module_, conventionally named `AppModule`.

  あらゆるAngularアプリには少なくともひとつのモジュールがあり（ルートモジュール）、慣習的に`AppModule`と名づけられます。

  While the _root module_ may be the only module in a small application, most apps have many more 
  _feature modules_, each a cohesive block of code dedicated to an application domain,
  a workflow, or a closely related set of capabilities.

  小規模なアプリケーションでは_ルートモジュール_が唯一のモジュールかもしれません。
  しかしほとんどのアプリではもっと多くの_機能モジュール_があり、それぞれはアプリケーションのドメイン、ワークフロー、
  または密接に関係した能力の一式といったものを専門とする、凝集したコードのかたまりです。

  An Angular module, whether a _root_ or _feature_, is a class with an `@NgModule` decorator.

  Angularのモジュールは、それが_ルート_であろうと_機能_であろうと、`@NgModule`デコレーターつきのクラスです。
.l-sub-section
  :marked
    Decorators are functions that modify JavaScript classes.
    Angular has many decorators that attach metadata to classes so that it knows
    what those classes mean and how they should work.
    <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank">
    Learn more</a> about decorators on the web.

    デコレーターは、JavaScriptのクラスを修飾する関数です。
    Angularはクラスにメタデータをつけ加えるたくさんのデコレーターを持っており、
    そのためそれらのクラスがどのようなもので、どのように動作するべきかを知っています。
    デコレーターについては、このwebサイトで
    <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank">
    さらに学んでください。</a>
:marked
  `NgModule` is a decorator function that takes a single metadata object whose properties describe the module. 
  The most important properties are:

  `NgModule`はデコレーター関数で、モジュールについての特徴を表現する複数のプロパティをもつ、単一のメタデータオブジェクトを受けとります。
  もっとも重要なプロパティは、
  * `declarations` - the _view classes_ that belong to this module.
  Angular has three kinds of view classes: [components](#components), [directives](#directives), and [pipes](pipes.html).

  * `declarations` - このモジュールに属する_ビュークラス_です。
  Angularでは三種類のビュークラスがあります。[コンポーネント](#components)、 [ディレクティブ](#directives)、そして[パイプ](pipes.html)です。

  * `exports` - the subset of declarations that should be visible and usable in the component [templates](#templates) of other modules.

  * `exports` - 他のモジュールにあるコンポーネントの[テンプレート](#templates)の中で、参照され使用される宣言の部分集合です。

  * `imports` - other modules whose exported classes are needed by component templates declared in _this_ module.

  * `imports` - このモジュールで宣言されたコンポーネントのテンプレートにおいて必要とされる、エクスポートされたクラスをもつ他のモジュール達です。

  * `providers` - creators of [services](#services) that this module contributes to
  the global collection of services; they become accessible in all parts of the app.

  * `providers` - [サービス](#services)を生成する機能で、このモジュールがそれをサービスのグローバルなコレクションに提供することで、
  サービスがアプリのすべての部分からアクセス可能になります。

  * `bootstrap` - the main application view, called the _root component_, 
  that hosts all other app views. Only the _root module_ should set this `bootstrap` property.

  * `bootstrap` - _ルートコンポーネント_と呼ばれるメインのアプリケーションのビューで、他のすべてのビューを提供します。
  _ルートモジュール_だけがこの`bootstrap`プロパティをセットするべきです。

  Here's a simple root module:

  単純なルートモジュールがこちらです。
+makeExample('app/mini-app.ts', 'module', 'app/app.module.ts')(format='.')

.l-sub-section
  :marked
    The `export` of `AppComponent` is just to show how to export; it isn't actually necessary in this example. A root module has no reason to _export_ anything because other components don't need to _import_ the root module.

    `AppComponent`の`export`は、単にexportの方法を示しているだけで、この例では実際には必要ありません。
    他のコンポーネントがルートモジュールを_インポート_する必要はないので、ルートモジュールはどんなものも_エクスポート_する理由がありません。
:marked
  Launch an application by _bootstrapping_ its root module. 
  During development you're likely to bootstrap the `AppModule` in a `main.ts` file like this one.

  ルートモジュールを_ブートストラップ_して、アプリケーションを起動しましょう。
  開発中は、このように`main.ts`ファイルの`AppModule`を起動することになるでしょう。
    
+makeExample('app/main.ts', '', 'app/main.ts')(format='.')

:marked
  ### Angular modules vs. JavaScript modules

  ### Angularのモジュール対JavaScriptのモジュール

  The Angular module &mdash; a class decorated with `@NgModule` &mdash; is a fundamental feature of Angular.

  Angularのモジュール（`@NgModule`で修飾されたクラス）は、Angularの必須機能です。

  JavaScript also has its own module system for managing collections of JavaScript objects.
  It's completely different and unrelated to the Angular module system.

  JavaScriptにも、JavaScriptのオブジェクトの集まりを管理する独自のモジュールシステムがあります。
  これはAngularのモジュールシステムとは全く別のものであり無関係です。
  
  In JavaScript each _file_ is a module and all objects defined in the file belong to that module.
  The module declares some objects to be public by marking them with the `export` key word. 
  Other JavaScript modules use *import statements* to access public objects from other modules.

  JavaScriptではそれぞれの_ファイル_はモジュールであり、そのファイルで定義されたすべてのオブジェクトはそのモジュールに属します。
  モジュールはいくつかのオブジェクトを、`export`という予約語を使用することで公開していると宣言します。
  他のJavaScriptのモジュールは*インポート文*を使用して、他のモジュールからの公開オブジェクトにアクセスします。

+makeExample('app/app.module.ts', 'imports', '')(format='.')
+makeExample('app/app.module.ts', 'export', '')(format='.')
  
.l-sub-section
  :marked
    <a href="http://exploringjs.com/es6/ch_modules.html" target="_blank">Learn more about the JavaScript module system on the web.</a>

    <a href="http://exploringjs.com/es6/ch_modules.html" target="_blank">このwebサイトで、JavaScriptのモジュールについてさらに学んでください。</a>
:marked
  These are two different and _complementary_ module systems. Use them both to write your apps.

  これらはふたつの異なる相補的なモジュールシステムです。アプリを作るために両方を使用してください。

  ### Angular libraries

  ### Angularのライブラリ

figure
  img(src="/resources/images/devguide/architecture/library-module.png" alt="Component" align="left" style="width:240px; margin-left:-40px;margin-right:10px" )

:marked
  Angular ships as a collection of JavaScript modules. You can think of them as library modules. 

  AngularはJavaScriptのモジュールの集まりとして提供されています。それらをライブラリのモジュールとして考えることができます。

  Each Angular library name begins with the `!{_at_angular}` prefix.

  各Angularのライブラリの名前は、`!{_at_angular}`接頭辞で始まります。

  You install them with the **npm** package manager and import parts of them with JavaScript `import` statements.

  **npm**パッケージマネージャーを使用してそれらをインストールし、JavaScriptの`import`文を使用してそれらの一部をインポートします。
<br clear="all"><br>
:marked
  For example, import Angular's `Component` decorator from the `@angular/core` library like this:

  たとえば、このように`@angular/core`ライブラリからAngularの`Component`デコレーターをインポートします。
+makeExample('app/app.component.ts', 'import', '')(format='.')
:marked
  You also import Angular _modules_ from Angular _libraries_ using JavaScript import statements:

  Angularの_ライブラリ_からの_モジュール_のインポートにも、JavaScriptのimport文を使用します。
+makeExample('app/mini-app.ts', 'import-browser-module', '')(format='.')
:marked
  In the example of the simple root module above, the application module needs material from within that `BrowserModule`. To access that material, add it to the `@NgModule` metadata `imports` like this.

  上記の単純なルートモジュールの例では、そのアプリケーションモジュールは`BrowserModule`の中にある情報を必要とします。
  その情報にアクセスするには、それをこのように`@NgModule`の`imports`メタデータに追加します。
+makeExample('app/mini-app.ts', 'ngmodule-imports', '')(format='.')
:marked
  In this way you're using both the Angular and JavaScript module systems _together_.

  この方法では、AngularとJavaScriptの両方のモジュールシステムを合わせて使用しています。

  It's easy to confuse the two systems because they share the common vocabulary of "imports" and "exports".
  Hang in there. The confusion yields to clarity with time and experience.

  そのふたつのシステムは"imports"と"exports"という普通の語彙を共有しているので、それらを混同しやすいですね。
  がんばりましょう。時間と経験とともに混同せずに明確に判別できるようになります。

.l-sub-section
  :marked
    Learn more from the [Angular modules](ngmodule.html) page.

    詳細は、[Angularのモジュール](ngmodule.html)ページを参照してください。

.l-hr 

.l-main-section
:marked
  <a id="components"></a>
  ## Components

  ## コンポーネント
figure
  img(src="/resources/images/devguide/architecture/hero-component.png" alt="Component" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )

:marked
  A _component_ controls a patch of screen called a *view*.

  _コンポーネント_は、*ビュー*と呼ばれる画面の一部分を制御します。

  For example, the following views are controlled by components:

  たとえば、以下のビューはコンポーネントにより制御されます。

  * The app root with the navigation links.
  * ナビゲーションリンク付きのアプリのルート。
  * The list of heroes.
  * ヒーローの一覧。
  * The hero editor.
  * ヒーローエディタ。


  You define a component's application logic&mdash;what it does to support the view&mdash;inside a class.
  The class interacts with the view through an API of properties and methods.

  クラスの内部で、コンポーネントのアプリケーションのロジック（ビューをサポートするために行うこと）を定義します。
  そのクラスはプロパティとメソッドのAPIを通じて、ビューと相互作用します。

  <a id="component-code"></a>
  For example, this `HeroListComponent` has a `heroes` property that returns !{_an} !{_array} of heroes
  that it acquires from a service.
  `HeroListComponent` also has a `selectHero()` method that sets a `selectedHero` property when the user clicks to choose a hero from that list.

  たとえば、この`HeroListComponent`は、サービスから取得したheroes配列を返す`heroes`プロパティをもっています。
  `HeroListComponent`は`selectHero()`メソッドも持っており、それはユーザーがクリックして一覧からひとりのヒーローを選択した時に、
  `selectedHero`プロパティをセットします。

+makeExcerpt('app/hero-list.component.ts', 'class')
:marked
  Angular creates, updates, and destroys components as the user moves through the application.
  Your app can take action at each moment in this lifecycle through optional [lifecycle hooks](lifecycle-hooks.html), like `ngOnInit()` declared above.

  Angularは、ユーザーがアプリケーションのあちこちに移動する際に、コンポーネントを生成し、更新し、破棄します。
  あなたのアプリはこのライフサイクルの中のそれぞれの瞬間に、上記で宣言した`ngOnInit()`のような任意の
  [ライフサイクルフック](lifecycle-hooks.html)を通じてコードを実行できます。

.l-hr 

.l-main-section
:marked
  ## Templates

  ## テンプレート
figure
  img(src="/resources/images/devguide/architecture/template.png" alt="Template" align="left" style="width:200px; margin-left:-40px;margin-right:10px" )
:marked
  You define a component's view with its companion **template**. A template is a form of HTML
  that tells Angular how to render the component.

  コンポーネントに付随する*テンプレート*を使用して、ビューを定義します。テンプレートはHTMLのひとつの形で、
  コンポーネントをレンダリングする方法をAngularに指示します。

  A template looks like regular HTML, except for a few differences. Here is a
  template for our `HeroListComponent`:

  テンプレートは、すこしの違い以外は通常のHTMLのように見えます。`HeroListComponent`のテンプレートがこちらです。

+makeExample('app/hero-list.component.html')

:marked
  Although this template uses typical HTML elements like `<h2>` and  `<p>`, it also has some differences. Code like `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]`, and `<hero-detail>` uses Angular's [template syntax](template-syntax.html).

  このテンプレートは`<h2>`や`<p>`のような典型的なHTMLの要素を使用していますが、いくつかの違いもあります。
  `*ngFor`、`{{hero.name}}`、`(click)`、`[hero]`、そして`<hero-detail>`のようなコードは、
  Angularの[テンプレート構文](template-syntax.html)を使用しています。

  In the last line of the template, the `<hero-detail>` tag is a custom element that represents a new component, `HeroDetailComponent`.

  テンプレートの最後の行における、`<hero-detail>`タグは`HeroDetailComponent`という新しいコンポーネントを表すカスタムエレメントです。
  
  The `HeroDetailComponent` is a *different* component than the `HeroListComponent` you've been reviewing.
  The `HeroDetailComponent` (code not shown) presents facts about a particular hero, the
  hero that the user selects from the list presented by the `HeroListComponent`.
  The `HeroDetailComponent` is a **child** of the `HeroListComponent`.

  `HeroDetailComponent`は、今までに調べてきた`HeroListComponent`とは*異なる*コンポーネントです。
  `HeroDetailComponent`（コードは表示されていません）は、`HeroListComponent`により表示された一覧からユーザーが選択した、
  特定のヒーローに関する事実を表示します。
  `HeroDetailComponent`は、`HeroListComponent`の*子*です。

figure
  img(src="/resources/images/devguide/architecture/component-tree.png" alt="Metadata" align="left" style="width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Notice how `<hero-detail>` rests comfortably among native HTML elements. Custom components mix seamlessly with native HTML in the same layouts.

  `<hero-detail>`がネイティブのHTML要素の間になじんでいることに注目してください。
  カスタムコンポーネントはネイティブのHTMLと共に、同じレイアウトの中で一体となって混在しています。

<br clear="all">

.l-hr 

.l-main-section
:marked
  ## Metadata

  ## メタデータ
figure
  img(src="/resources/images/devguide/architecture/metadata.png" alt="Metadata" align="left" style="width:150px; margin-left:-40px;margin-right:10px" )

:marked
<p style="padding-top:10px">Metadata tells Angular how to process a class.</p>
<p style="padding-top:10px">メタデータは、クラスを処理する方法をAngularに指示します。</p>
<br clear="all">
:marked
  [Looking back at the code](#component-code) for `HeroListComponent`, you can see that it's just a class.
  There is no evidence of a framework, no "Angular" in it at all.

  `HeroListComponent`の[コードをふり返れば](#component-code)、それはただのクラスであることが分かります。
  その中にはフレームワークの形跡、"Angular"は全くありません。

  In fact, `HeroListComponent` really is *just a class*. It's not a component until you *tell Angular about it*.

  実際、`HeroListComponent`は本当に*ただのクラス*です。*Angularにそれがコンポーネントであると指示する*までは。

  To tell Angular that `HeroListComponent` is a component, attach **metadata** to the class.

  Angularに`HeroListComponent`はコンポーネントであると指示するには、そのクラスに*メタデータ*をつけ加えます。

  In !{_Lang}, you attach metadata by using !{_a} **!{_decorator}**.
  Here's some metadata for `HeroListComponent`:

  !{_Lang}では、**デコレーター**を使用してメタデータをつけ加えます。
  `HeroListComponent`のいくつかのメタデータがこちらです。

+makeExcerpt('app/hero-list.component.ts', 'metadata')

:marked
  Here is the `@Component` !{_decorator}, which identifies the class
  immediately below it as a component class.

  ここには`@Component`デコレーターがあり、その直下のクラスをコンポーネントのクラスとして識別させます。

block ts-decorator
  :marked
    The `@Component` decorator takes a required configuration object with the
    information Angular needs to create and present the component and its view.

    `@Component`デコレーターは、Angularがコンポーネントとそのビューを作成し表示するための情報を持った設定オブジェクトを必要とします。

    Here are a few of the possible `@Component` configuration options:

    `@Component`の設定オプションとなりうるいくつかの例がこちらです。

:marked
  - `moduleId`: sets the source of the base address (`module.id`) for module-relative URLs such as the `templateUrl`.

  - `selector`: CSS selector that tells Angular to create and insert an instance of this component
  where it finds a `<hero-list>` tag in *parent* HTML.
  For example, if an app's  HTML contains `<hero-list></hero-list>`, then
  Angular inserts an instance of the `HeroListComponent` view between those tags.

  - `selector`: このコンポーネントのインスタンスを生成し挿入する場所をAngularに指示するCSSセレクタで、
  *親*HTMLの中で`<hero-list>`タグを探します。
  たとえば、もしアプリのHTMLが`<hero-list></hero-list>`を含むならば、Angularはそのタグの間に
  `HeroListComponent`のビューのインスタンスを挿入します。

  - `templateUrl`: module-relative address of this component's HTML template, shown [above](#templates).

  - `templateUrl`: [上記](#templates)に示した、このコンポーネントのHTMLテンプレートのアドレスです。

  - `directives`: !{_array} of the components or directives that *this* template requires.
  In the last line of `hero-list.component.html`, Angular inserts a `HeroDetailComponent`
  in the space indicated by `<hero-detail>` tags.
  Angular does so only if `HeroDetailComponent` is in this `directives` !{_array}.

  - `directives`: *この*テンプレートが必要とするコンポーネントまたはディレクティブの配列です。
  `hero-list.component.html`の最後の行の中で、Angularは`<hero-detail>`タグで示された空間に
  `HeroDetailComponent`を挿入します。
  Angularはそれを、`HeroDetailComponent`がこの`ディレクティブ`の配列のなかにある場合にだけ行います。

  - `providers`: !{_array} of **dependency injection providers** for services that the component requires.
  This is one way to tell Angular that the component's constructor requires a `HeroService`
  so it can get the list of heroes to display.

  - `providers`: コンポーネントが必要とするサービスのための、*依存性の注入のプロバイダー*についての配列です。
  これは、コンポーネントのコンストラクタが`HeroService`を必要とするとAngularに指示するひとつの方法で、
  これにより表示するヒーローの一覧を手に入れることができます。

figure
  img(src="/resources/images/devguide/architecture/template-metadata-component.png" alt="Metadata" align="left" style="height:200px; margin-left:-40px;margin-right:10px" )

:marked
  The metadata in the `@Component` tells Angular where to get the major building blocks you specify for the component.

  `@Component`のメタデータは、コンポーネントのために指定された主な基礎的要素をどこで手に入れるかをAngularに指示します。

  The template, metadata, and component together describe a view.

  テンプレート、メタデータ、そしてコンポーネントは、共同でビューを表現します。

  Apply other metadata !{_decorator}s in a similar fashion to guide Angular behavior.
  `@Injectable`, `@Input`, and `@Output` are a few of the more popular !{_decorator}s.

  同様の方法は他のメタデータのデコレーターにも当てはまり、Angularの振る舞いを導きます。
  `@Injectable`、`@Input`、そして`@Output`は、さらによく使用されるデコレーターです。
<br clear="all">
:marked
  The architectural takeaway is that you must add metadata to your code
  so that Angular knows what to do.

  アーキテクチャについて覚えておくことは、あなたはコードにメタデータを追加する必要があり、
  それによってAngularは何をするべきかを知るということです。

.l-hr 

.l-main-section
:marked
  ## Data binding

  ## データバインディング
  Without a framework, you would be responsible for pushing data values into the HTML controls and turning user responses
  into actions and value updates. Writing such push/pull logic by hand is tedious, error-prone, and a nightmare to
  read as any experienced jQuery programmer can attest.

  フレームワーク無しでは、データ値をHTMLに送りこんでの制御と、ユーザーの反応のアクションへの変換と値の更新を自分でしなければなりません。
  経験豊富なjQueryプログラマーなら誰でも証言できるように、そのようなプッシュ／プルのロジックを手で書くと、
  退屈で、エラーが発生しがちで、最悪に読みづらくなります。
figure
  img(src="/resources/images/devguide/architecture/databinding.png" alt="Data Binding" style="width:220px; float:left; margin-left:-40px;margin-right:20px" )
:marked
  Angular supports **data binding**,
  a mechanism for coordinating parts of a template with parts of a component.
  Add binding markup to the template HTML to tell Angular how to connect both sides.

  Angularは**データバインディング**をサポートしています。
  それはコンポーネントの一部とテンプレートの一部を同調させるメカニズムです。
  バインディングのマークアップをテンプレートのHTMLに追加して、双方を接続する方法をAngularに指示します。

  As the diagram shows, there are four forms of data binding syntax. Each form has a direction &mdash; to the DOM, from the DOM, or in both directions.

  図が示すように、データバインディングの構文は四種類あります。それぞれの種類は、DOMへ、DOMから、または双方向に、といった方向を持っています。
<br clear="all">
:marked
  The `HeroListComponent` [example](#templates) template has three forms:

  `HeroListComponent`の[例](#templates)のテンプレートでは、三種類があります。

+makeExcerpt('app/hero-list.component.1.html', 'binding')

:marked
  * The `{{hero.name}}` [*interpolation*](displaying-data.html#interpolation)
  displays the component's `hero.name` property value within the `<li>` tags.

  * `{{hero.name}}`[*補間*](displaying-data.html#interpolation)は、コンポーネントの`hero.name`プロパティの値を
  `<li>`タグの内側に表示します。

  * The `[hero]` [*property binding*](template-syntax.html#property-binding) passes the value of `selectedHero` from
  the parent `HeroListComponent` to the `hero` property of the child `HeroDetailComponent`.

  * `[hero]`[*プロパティバインディング*](template-syntax.html#property-binding)は、
  親である`HeroListComponent`からの`selectedHero`の値を、子である`HeroDetailComponent`の`hero`プロパティに渡します。

  * The `(click)` [*event binding*](user-input.html#click) calls the component's `selectHero` method when the user clicks a hero's name.

  * `(click)`[*イベントバインディング*](user-input.html#click)は、
  ユーザーがヒーローの名前をクリックしたとき、コンポーネントの`selectHero`メソッドを呼び出します。

  **Two-way data binding** is an important fourth form
  that combines property and event binding in a single notation, using the `ngModel` directive.
  Here's an example from the `HeroDetailComponent` template:

  **双方向データバインディング**は重要な四番目の種類で、`ngModel`ディレクティブを使用して、
  プロパティとイベントのバインディングを単一の表記で組みあわせます。
  `HeroDetailComponent`のテンプレートからの例がこちらです。

+makeExcerpt('app/hero-detail.component.html', 'ngModel')

:marked
  In two-way binding, a data property value flows to the input box from the component as with property binding.
  The user's changes also flow back to the component, resetting the property to the latest value,
  as with event binding.

  双方向バインディングでは、データプロパティの値はプロパティバインディングと同様に、コンポーネントからinputボックスに流れます。
  ユーザーの変更もまたイベントバインディングと同様に、コンポーネントに流れ戻ってそのプロパティを最新の値に更新します。

  Angular processes *all* data bindings once per JavaScript event cycle,
  from the root of the application component tree through all child components.

  Angularは、JavaScriptのイベントのサイクルごとに、アプリケーションのコンポーネントツリーのルートから
  すべての子コンポーネントにわたっての*すべての*データバインディングをいちどに処理します。

figure
  img(src="/resources/images/devguide/architecture/component-databinding.png" alt="Data Binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Data binding plays an important role in communication
  between a template and its component.

  データバインディングは、テンプレートとそのコンポーネントの間の情報伝達において重要な役割を演じます。
<br clear="all">
figure
  img(src="/resources/images/devguide/architecture/parent-child-binding.png" alt="Parent/Child binding" style="float:left; width:300px; margin-left:-40px;margin-right:10px" )
:marked
  Data binding is also important for communication between parent and child components.

  データバインディングは、親と子のコンポーネントの間の情報伝達においても重要です。
<br clear="all">

.l-hr 

.l-main-section
:marked
  ## Directives

  ## ディレクティブ
figure
  img(src="/resources/images/devguide/architecture/directive.png" alt="Parent child" style="float:left; width:150px; margin-left:-40px;margin-right:10px" )
:marked
  Angular templates are *dynamic*. When Angular renders them, it transforms the DOM
  according to the instructions given by **directives**.

  Angularのテンプレートは*動的*です。Angularがそれらをレンダリングするとき、**ディレクティブ**により与えられた指示に従って
  DOMを変形させます。

  A directive is a class with directive metadata. In !{_Lang}, apply the `@Directive` !{_decorator}
  to attach metadata to the class.

  ディレクティブはディレクティブメタデータつきのクラスです。
  !{_Lang}では、クラスにメタデータをつけ加えるために`@Directive`デコレーターを適用します。
<br clear="all">
:marked
  A component is a *directive-with-a-template*;
  a `@Component` !{_decorator} is actually a `@Directive` !{_decorator} extended with template-oriented features.

  コンポーネントは、*テンプレートつきのディレクティブ*です。`@Component`デコレーターは実際、テンプレート指向の機能を使用して
  拡張された`@Directive`デコレーターです。

.l-sub-section
  :marked
    While **a component is technically a directive**,
    components are so distinctive and central to Angular applications that this architectural overview  separates components from directives.

    **コンポーネントは技術的にはディレクティブです**が、コンポーネントはAngularアプリケーションにとって非常に特徴的で中心的なものなので、
    このアーキテクチャの概要では、ディレクティブからコンポーネントを区別しています。
:marked
  Two *other* kinds of directives exist: _structural_ and _attribute_ directives.

  *他にも*二種類の種類のディレクティブがあります。_構造_ディレクティブと、_属性_ディレクティブです。

  They tend to appear within an element tag as attributes do,
  sometimes by name but more often as the target of an assignment or a binding.

  それらは、属性がそうであるように、要素のタグの内側に現れる傾向があり、
  ときには名前で、しかしより頻繁には代入またはバインディングの対象として現れます。

  **Structural** directives alter layout by adding, removing, and replacing elements in DOM.

  **構造**ディレクティブは、DOMの要素を追加し、削除し、そして取りかえることにより、レイアウトを変更します。

  The [example template](#templates) uses two built-in structural directives:

  [例のテンプレート](#templates)は、ふたつの組み込みの構造ディレクティブを使用しています。

+makeExcerpt('app/hero-list.component.1.html', 'structural')

:marked
  * [`*ngFor`](displaying-data.html#ngFor) tells Angular to stamp out one `<li>` per hero in the `heroes` list.
  * [`*ngFor`](displaying-data.html#ngFor)は、`heroes`一覧のなかのヒーローあたりひとつの`<li>`を表示するようにAngularに指示します。
  * [`*ngIf`](displaying-data.html#ngIf) includes the `HeroDetail` component only if a selected hero exists.
  * [`*ngIf`](displaying-data.html#ngIf)は、選択したヒーローが存在する場合のみ、`HeroDetail`コンポーネントを含めます。

block dart-bool
  //- N/A

:marked
  **Attribute** directives alter the appearance or behavior of an existing element.
  In templates they look like regular HTML attributes, hence the name.

  **属性**ディレクティブは、存在する要素の外見または振る舞いを変更します。
  テンプレートのなかで、それらはその名のとおり、通常のHTMLの属性のように見えます。

  The `ngModel` directive, which implements two-way data binding, is
  an example of an attribute directive. `ngModel` modifies the behavior of
  an existing element (typically an `<input>`)
  by setting its display value property and responding to change events.

  双方向データバインディングを実装する`ngModel`ディレクティブが、属性ディレクティブの例です。
  `ngModel`は、（典型的には`<input>`のような）既存の要素の振る舞いを、
  表示している値のプロパティをセットし、変更イベントに反応することによって変更します。

+makeExcerpt('app/hero-detail.component.html', 'ngModel')
:marked
  Angular has a few more directives that either alter the layout structure
  (for example, [ngSwitch](template-syntax.html#ngSwitch))
  or modify aspects of DOM elements and components
  (for example, [ngStyle](template-syntax.html#ngStyle) and [ngClass](template-syntax.html#ngClass)).

  Angularにはさらにいくつかのディレクティブがあり、それらはレイアウトの構造を変更したり
  （たとえば, [ngSwitch](template-syntax.html#ngSwitch)）、またはDOMの要素およびコンポーネントの外見を変更したりします
  （たとえば, [ngStyle](template-syntax.html#ngStyle)と[ngClass](template-syntax.html#ngClass)）。

  Of course, you can also write your own directives. Components such as
  `HeroListComponent` are one kind of custom directive.
  <!-- PENDING: link to where to learn more about other kinds! -->

  もちろん、独自のディレクティブを書くこともできます。`HeroListComponent`のようなコンポーネントはカスタムディレクティブの一種です。

.l-hr 

.l-main-section
:marked
  ## Services

  ## サービス
figure
  img(src="/resources/images/devguide/architecture/service.png" alt="Service" style="float:left; margin-left:-40px;margin-right:10px" )
:marked
  _Service_ is a broad category encompassing any value, function, or feature that your application needs.

  _サービス_は、あなたのアプリケーションが必要とするどのような値、関数、または機能も含む広い範疇です。

  Almost anything can be a service.
  A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.

  ほとんどすべてのものがサービスになることができます。
  サービスは、典型的には、範囲をしぼって十分に明確にされた目的をもつクラスです。なにか特定のものを実行すべきで、そしてそれをうまくやるべきです。
<br clear="all">
:marked
  Examples include:

  以下の例が挙げられます。
  * logging service
  * ロギングサービス
  * data service
  * データサービス
  * message bus
  * メッセージバス
  * tax calculator
  * 税金計算機
  * application configuration
  * アプリケーションの設定

  There is nothing specifically _Angular_ about services. Angular has no definition of a service.
  There is no service base class, and no place to register a service.

  サービスに関しては、_Angular_特有のものはありません。Angularにはサービスについての定義はありません。
  サービスの基底クラスはありませんし、サービスを登録する場所もありません。

  Yet services are fundamental to any Angular application. Components are big consumers of services.

  それでもサービスは、どのようなAngularアプリケーションにとっても欠かせません。コンポーネントはサービスの重要な消費者です。

  Here's an example of a service class that logs to the browser console:

  ブラウザーのコンソールにログを吐くサービスの例がこちらです。

+makeExcerpt('app/logger.service.ts', 'class')

:marked
  Here's a `HeroService` that fetches heroes and returns them in a resolved !{_PromiseLinked}.
  The `HeroService` depends on the `Logger` service and another `BackendService` that handles the server communication grunt work.

  ヒーローたちをフェッチして、解決された!{_PromiseLinked}につつまれた彼らを返す`HeroService`がこちらです。
  `HeroService`は`Logger`サービスと、もう一つの`BackendService`に依存しています。
  `BackendService`はサーバーとの通信のつまらない仕事を処理します。


+makeExcerpt('app/hero.service.ts', 'class')

:marked
  Services are everywhere.

  サービスはどこにでもあります。

  Component classes should be lean. They don't fetch data from the server,
  validate user input, or log directly to the console.
  They delegate such tasks to services.

  コンポーネントのクラスは薄くあるべきです。コンポーネントはデータをサーバーからフェッチしたり、ユーザーのインプットをバリデートしたり、
  直接コンソールにログを吐いたりはしません。
  そのような作業はサービスに移譲します。

  A component's job is to enable the user experience and nothing more. It mediates between the view (rendered by the template)
  and the application logic (which often includes some notion of a _model_).
  A good component presents properties and methods for data binding.
  It delegates everything nontrivial to services.

  コンポーネントの仕事はユーザー体験を与えることで、それ以上のものではありません。それはビュー（テンプレートによりレンダリングされます）と
  アプリケーションのロジック（_モデル_に関するなんらかの概念を含むことがよくあります）の間を仲介します。

  Angular doesn't *enforce* these principles.
  It won't complain if you write a "kitchen sink" component with 3000 lines.

  Angularはこれらの原則を*強制しません*。
  あなたが3000行からなる"なんでもかんでも詰めこんだ"コンポーネントを書いても、不平を言うことは無いでしょう。

  Angular does help you *follow* these principles by making it easy to factor your
  application logic into services and make those services available to components through *dependency injection*.

  Angularがすることは、あなたがこれらの原則を*守る*手助けです。あなたのアプリケーションのロジックをサービスに含め、
  それらのサービスを*依存性の注入*を通じてコンポーネントで利用可能にすることを簡単にしてくれます。

.l-hr 

.l-main-section
:marked
  ## Dependency injection

  ## 依存性の注入
figure
  img(src="/resources/images/devguide/architecture/dependency-injection.png" alt="Service" style="float:left; width:200px; margin-left:-40px;margin-right:10px" )
:marked
  _Dependency injection_ is a way to supply a new instance of a class
  with the fully-formed dependencies it requires. Most dependencies are services.
  Angular uses dependency injection to provide new components with the services they need.

  _依存性の注入_は、クラスの新しいインスタンスをそれが必要とする完全な形の依存性とともに提供する方法です。依存性のほとんどはサービスです。
  Angularは依存性の注入を、必要なサービスを伴った新しいコンポーネントを提供するために使用します。
<br clear="all">
:marked
  Angular can tell which services a component needs by looking at the types of its constructor parameters.
  For example, the constructor of your `HeroListComponent` needs a `HeroService`:

  Angularは、コンポーネントにどのサービスが必要かを、そのコンストラクタのパラメーターの型を見ることで判断できます。
  たとえば、`HeroListComponent`のコンストラクタには`HeroService`が必要です。

+makeExcerpt('app/hero-list.component.ts (constructor)', 'ctor')

:marked
  When Angular creates a component, it first asks an **injector** for
  the services that the component requires.

  Angularがコンポーネントを生成するとき、Angularはまずは**インジェクター**にコンポーネントが必要とするサービスを要求します。

  An injector maintains a container of service instances that it has previously created.
  If a requested service instance is not in the container, the injector makes one and adds it to the container
  before returning the service to Angular.
  When all requested services have been resolved and returned,
  Angular can call the component's constructor with those services as arguments.
  This is *dependency injection*.

  インジェクターは、以前に生成されたサービスのインスタンスについてのコンテナを維持します。
  要求されたサービスのインスタンスがコンテナにない場合は、インジェクターはそれを作成してコンテナに追加し、それからそれをAngularに返します。
  すべての要求されたサービスが解決され返されたとき、Angularはそれらのサービスを引数にして
  コンポーネントのコンストラクタを呼び出すことができます。
  これが、*依存性の注入*です。

  The process of `HeroService` injection looks a bit like this:

  `HeroService`の注入の処理は、いくぶんこのように見えます。
figure
  img(src="/resources/images/devguide/architecture/injector-injects.png" alt="Service" )
:marked
  If the injector doesn't have a `HeroService`, how does it know how to make one?

  もしインジェクターが`HeroService`を持っていないならば、それを作成する方法をどうやって知るのでしょうか？

  In brief, you must have previously registered a **provider** of the `HeroService` with the injector.
  A provider is something that can create or return a service, typically the service class itself.

  手短に言えば、事前に`HeroService`の**プロバイダー**をインジェクターに登録しておかなければなりません。
  プロバイダーはサービスを生成するか返すことができるもので、典型的にはサービスのクラスそのものです。

  You can register providers in modules or in components.

  モジュールかコンポーネントのなかでプロバイダーを登録することができます。
  
  In general, add providers to the [root module](#module) so that
  the same instance of a service is available everywhere.

  一般的に、プロバイダーを[ルートモジュール](#module)に追加することで、サービスの同じインスタンスがどこでも利用可能になります。

+makeExample('app/app.module.ts', 'providers', 'app/app.module.ts (module providers)')(format='.')

:marked
  Alternatively, register at a component level in the `providers` property of the `@Component` metadata:

  あるいは、`@Component`メタデータの`providers`プロパティのなかで、コンポーネントの段階で登録します。

+makeExample('app/hero-list.component.ts', 'providers', 'app/hero-list.component.ts (component providers)')(format='.')

:marked
  Registering at a component level means you get a new instance of the
  service with each new instance of that component.

  コンポーネントの段階で登録するということは、
  そのコンポーネントの新しいインスタンスごとにサービスの新しいインスタンスが手に入るということを意味します。

  <!-- We've vastly oversimplified dependency injection for this overview.
  The full story is in the [dependency injection](dependency-injection.html) page. -->

  Points to remember about dependency injection:

  依存性の注入について覚えておく点は、

  * Dependency injection is wired into the Angular framework and used everywhere.
  * 依存性の注入はAngularのフレームワークの内側に配線されていて、あらゆるところで使用されています。

  * The *injector* is the main mechanism.
  * *インジェクター*が主なメカニズムです。

    * An injector maintains a *container* of service instances that it created.
    * インジェクターは、生成したサービスのインスタンスについての*コンテナ*を維持します。
    * An injector can create a new service instance from a *provider*.
    * インジェクターは、*プロバイダー*から新しいサービスのインスタンスを生成できます。

  * A *provider* is a recipe for creating a service.
  * *プロバイダー*は、サービスを生成するためのレシピです。

  * Register *providers* with injectors.
  * インジェクターを使用して*プロバイダー*を登録します。

.l-hr 

.l-main-section
:marked
  ## Wrap up

  ## まとめ

  You've learned the basics about the eight main building blocks of an Angular application:

  あなたはAngularアプリケーションの八つの主な基礎的要素についての基礎を学習しました。

  * [Modules](#modules)
  * [モジュール](#modules)
  * [Components](#components)
  * [コンポーネント](#components)
  * [Templates](#templates)
  * [テンプレート](#templates)
  * [Metadata](#metadata)
  * [メタデータ](#metadata)
  * [Data binding](#data-binding)
  * [データバインディング](#data-binding)
  * [Directives](#directives)
  * [ディレクティブ](#directives)
  * [Services](#services)
  * [サービス](#services)
  * [Dependency injection](#dependency-injection)
  * [依存性の注入](#dependency-injection)

  That's a foundation for everything else in an Angular application,
  and it's more than enough to get going.
  But it doesn't include everything you need to know.

  以上がAngularアプリケーションにおけるその他のあらゆるもののための基礎で、
  これで十二分に進むことができます。
  しかし、あなたが知る必要のあるすべてを網羅してはいません。

  Here is a brief, alphabetical list of other important Angular features and services.
  Most of them are covered in this documentation (or soon will be).

  他の重要なAngularの機能とサービスについての、簡潔なアルファベット順の一覧がこちらです。
  それらのほとんどはこのドキュメンテーションで扱っています。（または、まもなく扱うでしょう）

  > [**Animations**](animations.html): Animate component behavior
  without deep knowledge of animation techniques or CSS with Angular's animation library.

  > [**アニメーション**](animations.html): アニメーションの技術やCSSについての深い知識を必要とせずに、
  Angularのアニメーションライブラリを使用して、コンポーネントの振る舞いをアニメーションさせます。

  > **Change detection**: The change detection documentation will cover how Angular decides that a component property value has changed,
  when to update the screen, and how it uses **zones** to intercept asynchronous activity and run its change detection strategies.

  > **変更検知**: 変更検知のドキュメンテーションは、Angularがどうやってコンポーネントのプロパティの値が変更されたことを判断するか、
  いつ画面を更新するべきか、そしてどうやって**zone**を使用して非同期の動作を横取りし、変更検知の戦略を実行するかについて扱います。

  > **Events**: The events documentation will cover how to use components and services to raise events with mechanisms for
  publishing and subscribing to events.

  > **イベント**: イベントのドキュメンテーションは、イベントの公開と購読のためのメカニズムを使用してイベントを発生させるための
  コンポーネントとサービスの使用方法ついて扱います。

  > [**Forms**](forms.html): Support complex data entry scenarios with HTML-based validation and dirty checking.

  > [**フォーム**](forms.html): HTMLベースのバリデーションとダーティーチェッキングを使用した複雑なデータ記入のシナリオをサポートします。

  > [**HTTP**](server-communication.html): Communicate with a server to get data, save data, and invoke server-side actions with an HTTP client.

  > [**HTTP**](server-communication.html): HTTPクライアントを使用してサーバーと通信し、データを取得し、データを保存し、
  そしてサーバーサイドのアクションを呼び出します。

  > [**Lifecycle hooks**](lifecycle-hooks.html): Tap into key moments in the lifetime of a component, from its creation to its destruction,
  by implementing the lifecycle hook interfaces.

  > [**ライフサイクルフック**](lifecycle-hooks.html): ライフサイクルフックのインターフェースを実装することで、
  コンポーネントの生成から破棄までの一生のなかで鍵となる瞬間を利用します。

  > [**Pipes**](pipes.html): Use pipes in your templates to improve the user experience by transforming values for display. Consider this `currency` pipe expression:

  > [**パイプ**](pipes.html): 表示する値を変換することでユーザー体験を改善するために、テンプレートのなかでパイプを使用します。
  この`currency`パイプ式を考えてみます。
<div style="margin-left:40px">
code-example().
  price | currency:'USD':true
</div>
:marked
  > It displays a price of "42.33" as `$42.33`.

  > "42.33"という値段を`$42.33`として表示します。

  > [**Router**](router.html): Navigate from page to page within the client
    application and never leave the browser.

  > [**ルーター**](router.html): クライアントアプリケーションの内側でページからページへと案内し、ブラウザーから離れることはありません。

  > [**Testing**](testing.html): Run unit tests on your application parts as they interact with the Angular framework
  using the _Angular Testing Platform_.

  > [**テスト**](testing.html): Angularのフレームワークと相互作用するように、tk_Angular Testing Platform_を使用して、
  あなたのアプリケーションの一部分の上で単体テストを実行します。
