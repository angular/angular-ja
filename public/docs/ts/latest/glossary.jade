block includes
  include _util-fns

//- current.path = ['docs', lang, 'latest', ...]
- var lang = current.path[1]
- var docsPath='/' + current.path[0]
- var docsLatest='/' + current.path.slice(0,3).join('/');
- var _at = lang === 'js' ? '' : '@'
- var _decoratorLink = '<a href="#' + _decorator + '">' + _decorator + '</a>'

:marked
  # Angular Glossary
  # Angular  用語集

  Angular has a vocabulary of its own.
  Most Angular terms are everyday English words
  with a specific meaning within the Angular system.

  Angularには独自の用語があります。
  ほとんどのAngularの用語は、Angularシステムの中で特別な意味をもつ常用英単語です。

  This glossary lists the most prominent terms
  and a few less familiar ones that have unusual or
  unexpected definitions.

  ここには主要な用語といくつかのあまり馴染みのない用語を集めています。

  [A](#A) [B](#B) [C](#C) [D](#D) [E](#E) [F](#F) [G](#G) [H](#H) [I](#I)
  [J](#J) [K](#K) [L](#L) [M](#M) [N](#N) [O](#O) [P](#P) [Q](#Q) [R](#R)
  [S](#S) [T](#T) [U](#U) [V](#V) [W](#W) [X](#X) [Y](#Y) [Z](#Z)

.l-main-section#A

+ifDocsFor('ts')
  a#aot
  :marked
    ## Ahead-of-time (AoT) compilation
    ## 事前コンパイラ (Ahead-of-time (AoT) compilation)
  .l-sub-section
    :marked
      You can compile Angular applications at build-time.
      By compiling your application using the compiler-cli, `ngc`, you can bootstrap directly
      to a module factory, meaning you don't need to include the Angular compiler in your JavaScript bundle.
      Ahead-of-time compiled applications also benefit from decreased load time and increased performance.

      Angularアプリケーションは、開発者が開発時にコンパイルすることができます。
      compiler-cli、別名`ngc`を使用してアプリケーションをコンパイルすることで、Module Factoryを直接起動することができます。
      つまり、JavaScriptのバンドルの中にAngularのコンパイラは必要ありません。
      また、事前コンパイルしたアプリケーションは読み込み時間が短縮され、パフォーマンスも向上する利点があります。

  :marked
    ## Angular module
    ## Angularモジュール (Angular module)
  .l-sub-section
    :marked
      Helps you organize an application into cohesive blocks of functionality.
      An Angular module identifies the components, directives, and pipes that the application uses along with the list of external Angular modules that the application needs, such as `FormsModule`.

      Every Angular application has an application root module class. By convention, the class is
      called `AppModule` and resides in a file named `app.component.ts`.

      あらゆるAngularアプリケーションはひとつのアプリケーションルートモジュールクラスをもちます。
      慣例的にそのクラスは`AppModule`と呼ばれ、`app.module.ts`ファイル内に配置されます。

      For details and examples, see the [Angular Module](!{docsLatest}/guide/ngmodule.html) page.

      詳細や例は[Angular Module](/docs/ts/latest/guide/ngmodule.html)の章を参照してください。

+ifDocsFor('ts|dart')
  :marked
    ## Annotation
    ## アノテーション (Annotation)
  .l-sub-section
    block annotation-defn
      :marked
        In practice, a synonym for [Decoration](#decorator).

        [デコレーター](#decorator)のことを指します。

:marked
  ## Attribute directive
  ## 属性ディレクティブ (Attribute directive)
.l-sub-section
  :marked
    A category of [directive](#directive) that can listen to and modify the behavior of
    other HTML elements, attributes, properties, and components. They are usually represented
    as HTML attributes, hence the name.

    [ディレクティブ](#directive)の一種で、他のHTML要素、属性、プロパティやコンポーネントの振る舞いを監視し、変更することができます。
    その名前のとおり、通常これらはHTML属性として現れます。

    A good example of an attribute directive is the `ngClass` directive for adding and removing CSS class names.

    `ngClass`ディレクティブはCSSクラス名を追加したり削除したりするためのもので、属性ディレクティブの良い例です。

.l-main-section#B

+ifDocsFor('ts|js')
  :marked
    ## Barrel

    ## バレル (Barrel)
  .l-sub-section
    :marked
      A barrel is a way to *rollup exports* from several ES2015 modules into a single convenient ES2015 module.
      The barrel itself is an ES2015 module file that re-exports *selected* exports of other ES2015 modules.

      バレルは、複数のES2015モジュールをひとつのES2015モジュールに*まとめてエクスポートする*方法です。
      バレル自身は、ES2015モジュールのファイルであり、*選択された*他のES2015モジュールのエクスポートを再エクスポートします。

      Imagine three ES2015 modules in a `heroes` folder:

      `heroes`フォルダにある、3つのES2015モジュールをイメージしてください：
    code-example.
      // heroes/hero.component.ts
      export class HeroComponent {}

      // heroes/hero.model.ts
      export class Hero {}

      // heroes/hero.service.ts
      export class HeroService {}
    :marked
      Without a barrel, a consumer would need three import statements:

      バレル無しでは、3つのインポート文を書く必要があります。
    code-example.
      import { HeroComponent } from '../heroes/hero.component.ts';
      import { Hero }          from '../heroes/hero.model.ts';
      import { HeroService }   from '../heroes/hero.service.ts';
    :marked
      You can add a barrel to the `heroes` folder (called `index`, by convention) that exports all of these items:

      これらすべてをエクスポートしている`heroes`フォルダ（慣例的に`index`と呼ばれます）にバレルを追加できます。
    code-example.
      export * from './hero.model.ts';   // re-export all of its exports
      export * from './hero.service.ts'; // re-export all of its exports
      export { HeroComponent } from './hero.component.ts'; // re-export the named thing
    :marked
      Now a consumer can import what it needs from the barrel.

      これでバレルから必要なものをインポートできるようになります。
    code-example.
      import { Hero, HeroService } from '../heroes'; // index is implied
    :marked
      The Angular [scoped packages](#scoped-package) each have a barrel named `index`.

      Angularの[スコープ化パッケージ](#scoped-package)それぞれが`index`という名前のバレルを持っています。

      That's why we can write this:

      というわけで、下記のように記述することができるのです：

    +makeExcerpt('quickstart/ts/app/app.component.ts', 'import', '')

    .alert.is-important
      :marked
        Note that you can often achieve this using [Angular modules](#angular-module) instead.

        同じ目的のために、[Angularモジュール](#angular-module)を使うことがあるので覚えておきましょう。

:marked
  ## Binding
  ## バインディング (Binding)
.l-sub-section
  :marked
    Almost always refers to [Data Binding](#data-binding) and the act of
    binding an HTML object property to a data object property.

    ほとんどの場合、[データバインディング](#data-binding)のことを指します。
    その役割は、HTMLオブジェクトのプロパティと、データオブジェクトのプロパティを結びつけることです。

    May refer to a [dependency injection](#dependency-injection) binding
    between a "token", also referred to as a "key", and a dependency [provider](#provider).
    This more rare usage should be clear in context.

    また、"トークン"または"キー" と依存性の[プロバイダー](#provider)との間を結びつける、[依存性の注入](#dependency-injection)を指すこともあります。
    この珍しい使い方は、文脈により理解できるはずです。

:marked
  ## Bootstrap
  ## ブートストラップ (Bootstrap)
.l-sub-section
  block bootstrap-defn-top
    :marked
      You launch an Angular application by "bootstrapping" it using the application root Angular module (`AppModule`). Bootstrapping identifies an application's top level "root" [component](#component), which is the first component that is loaded for the application. For more information, see [QuickStart](!{docsLatest}/quickstart.html).

      Angularアプリケーションは、ルートAngularモジュール(`AppModule`)を利用した "ブートストラッピング" により起動します。
      ブートストラッピングは、アプリケーションで最初にロードされる最上位の "ルート" [コンポーネント](#component)を識別します。
      詳細は[クイックスタート](/docs/ts/latest/quickstart.html)を参照してください。

  :marked
    You can bootstrap multiple apps in the same `index.html`, each with its own top level root.

    同じ`index.html`の中で、複数のアプリケーションをそれぞれのルートコンポーネントを使ってブートストラップできます。

.l-main-section#C
:marked
  ## camelCase

  ## キャメルケース (camelCase)
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter
    _except the first letter, which is lowercase_.

    複合語や句を、_最初の文字は小文字で書き_、以降はそれぞれの単語または略語が大文字で始まるように書く方法です。

    Function, property, and method names are typically spelled in camelCase. Examples include: `square`, `firstName` and `getHeroes`. Notice that `square` is an example of how you write a single word in camelCase.

    関数、プロパティ、およびメソッド名は一般的にキャメルケースでつづられます。`square`、`firstName`、および`getHeroes`が例として挙げられます。

    This form is also known as **lower camel case**, to distinguish it from **upper camel case**, which is [PascalCase](#pascalcase).
    When you see "camelCase" in this documentation it always means *lower camel case*.

    この形式は**ロウワーキャメルケース**としても知られ、[パスカルケース](#pascalcase)と呼ばれる**アッパーキャメルケース**と区別します。
    このドキュメンテーションでは、"キャメルケース"とは常に*ロウワーキャメルケース*のことです。

:marked
  ## Component

  ## コンポーネント (Component)
.l-sub-section
  :marked
    An Angular class responsible for exposing data to a [view](#view) and handling most of the view’s display and user-interaction logic.
    
    [ビュー](#view)にデータを伝えること、そしてビューの表示やユーザーインタラクションを処理することを担うAngularのクラスです。

    The *component* is one of the most important building blocks in the Angular system.
    It is, in fact, an Angular [directive](#directive) with a companion [template](#template).

    コンポーネントは、Angularシステムにおいてもっとも重要な構成要素のひとつです。
    その実体は、[テンプレート](#template)を使用したAngular[ディレクティブ](#directive)のことです。

    You apply the `!{_at}Component` !{_decoratorLink} to
    the component class, thereby attaching to the class the essential component metadata
    that Angular needs to create a component instance and render it with its template
    as a view.

    開発者が`!{_at}Component` !{_decoratorLink}をコンポーネントクラスに付けることによって、
    Angularがコンポーネントのインスタンスを作成し、テンプレートを使ってビューとしてレンダリングするために
    必要とする基本的なコンポーネントのメタデータを、そのクラスに付加します。

    Those familiar with "MVC" and "MVVM" patterns will recognize
    the component in the role of "controller" or "view model".

    "MVC"あるいは"MVVM"パターンを熟知した人であれば、コンポーネントが"コントローラー"あるいは"ビューモデル"の役割だとわかるでしょう。

.l-main-section#D
:marked
  ## dash-case

  ## ダッシュケース (dash-case)
.l-sub-section
  :marked
    The practice of writing compound words or phrases such that each word is separated by a dash or hyphen (`-`).
    This form is also known as [kebab-case](#kebab-case).

    複合語や句を、それぞれの単語がひとつのダッシュやハイフン (`-`) で隔てられるように書く方法です。
    この形式は[ケバブケース](#kebab-case)としても知られています。

    [Directive](#directive) selectors (like `my-app`) <span if-docs="ts">and
    the root of filenames (such as `hero-list.component.ts`)</span> are often
    spelled in dash-case.

    (`my-app`のような)[ディレクティブ](#directive)セレクター <span if-docs="ts">や(`hero-list.component.ts`のような)ファイル名
    </span>は、よくダッシュケースで記述されます。

:marked
  ## Data binding
  ## データバインディング (Data binding)
.l-sub-section
  :marked
    Applications display data values to a user and respond to user
    actions (clicks, touches, keystrokes).

    アプリケーションはデータの値をユーザーに表示し、ユーザーからのアクション(クリック、タッチ、キーストローク)に反応します。

    Instead of manually pushing application data values into HTML, attaching
    event listeners, pulling changed values from the screen, and
    updating application data values, you can use data binding by declaring the relationship between an HTML widget and data source and let the
    framework handle the details.

    データの値をHTMLに与え、イベントリスナーを付加し、スクリーンから変更された値を取得し、そしてデータの値を更新します。これらはすべて手動でやることもできます。
    もしくは、HTMLウィジェットとアプリケーションデータソースの間の関係を定義して、データバインディングフレームワークが詳細を処理するようにすることもできます。

    Angular has a rich data binding framework with a variety of data binding
    operations and supporting declaration syntax.

    Angularは、多様なデータバインディング操作と宣言構文をサポートする高機能なデータバインディングフレームワークを供えています。

     Read about the forms of binding in the [Template Syntax](!{docsLatest}/guide/template-syntax.html#data-binding) page:

     データバインディングについて詳しく知るには
    [テンプレート構文](!{docsLatest}/guide/template-syntax.html#data-binding)の章を参照してください。
     * [Interpolation](!{docsLatest}/guide/template-syntax.html#interpolation).
     * [補間](!{docsLatest}/guide/template-syntax.html#interpolation)
     * [Property binding](!{docsLatest}/guide/template-syntax.html#property-binding).
     * [プロパティバインディング](!{docsLatest}/guide/template-syntax.html#property-binding)
     * [Event binding](!{docsLatest}/guide/template-syntax.html#event-binding).
     * [イベントバインディング](!{docsLatest}/guide/template-syntax.html#event-binding)
     * [Attribute binding](!{docsLatest}/guide/template-syntax.html#attribute-binding).
     * [属性バインディング](!{docsLatest}/guide/template-syntax.html#attribute-binding)
     * [Class binding](!{docsLatest}/guide/template-syntax.html#class-binding).
     * [クラスバインディング](!{docsLatest}/guide/template-syntax.html#class-binding)
     * [Style binding](!{docsLatest}/guide/template-syntax.html#style-binding).
     * [スタイルバインディング](!{docsLatest}/guide/template-syntax.html#style-binding)
     * [Two-way data binding with ngModel](!{docsLatest}/guide/template-syntax.html#ngModel).
     * [ngModelによる双方向バインディング](!{docsLatest}/guide/template-syntax.html#ng-model)

+ifDocsFor('ts|dart')
  a#decorator
  a#decoration
  :marked
    ## 
    ## デコレーター | デコレーション (Decorator | decoration)
  .l-sub-section
    block decorator-defn
      :marked
        A decorator is a **function** that adds metadata to a class, its members (properties, methods) and function arguments.

        デコレーターは**関数**であり、クラス、メンバー（プロパティおよびメソッド）、および関数の引数にメタデータを付加します。

        Decorators are a JavaScript language [feature](https://github.com/wycats/javascript-decorators), implemented in TypeScript and proposed for ES2016 (AKA ES7).

        デコレーターはJavaScript言語の[機能](https://github.com/wycats/javascript-decorators)で、TypeScript で実装され、
        (ES7として知られる)ES2016で提案されています。

        To apply a decorator, position it immediately above or to the left of the thing it decorates.

        デコレーターを適用するには、修飾する対象の直上か左にデコレーターを配置します。

        Angular has its own set of decorators to help it interoperate with your application parts.
        Here is an example of a `@Component` decorator that identifies a
        class as an Angular [component](#component) and an `@Input` decorator applied to the `name` property
        of that component. The elided object argument to the `@Component` decorator would contain the pertinent component metadata.

        Angularは独自のデコレーターを持っており、Angularとアプリケーションの部品が協調して動く手助けをします。
        こちらは、クラスをAngularの[コンポーネント](#component)と識別する`@Component`デコレーター、およびそのコンポーネントのプロパティに適用される`@Input`デコレーターの例です。
        ここでは省略した`@Component`の引数オブジェクトには、関連するコンポーネントのメタデータを含めます。

        ```
        @Component({...})
        export class AppComponent {
          constructor(@Inject('SpecialFoo') public foo:Foo) {}
          @Input() name:string;
        }
        ```
        The scope of a decorator is limited to the language feature
        that it decorates. None of the decorations shown here will "leak" to other
        classes appearing below it in the file.

        デコレーターの範囲は、それが修飾するJavaScript言語の機能に限られます。
        ここでいう修飾は、同一ファイルの中でそれ以降にある他のクラスにまで及ぶわけではありません。

      .alert.is-important
        :marked
          Always include parentheses `()` when applying a decorator.

          デコレーターを適用する際には、常に丸括弧`()`を含めてください。
          デコレーターは、適用する際に必ず呼び出される**関数**です。

:marked
  ## Dependency injection
  ## 依存性の注入 (Dependency injection)
.l-sub-section
  :marked
    Dependency injection is both a design pattern and a mechanism
    for creating and delivering parts of an application to other
    parts of an application that request them.

    依存性の注入は、アプリケーションの部品に求められた部品を作って送り届けるためのデザインパターンでありメカニズムです。

    Angular developers prefer to build applications by defining many simple parts
    that each do one thing well and then wiring them together at runtime.

    Angularの開発者は、ひとつのことだけをするシンプルな部品をたくさん定義することでアプリケーションを組み立てることを好み、
    その後、実行時にそれぞれをつなぎます。

    These parts often rely on other parts. An Angular [component](#component)
    part might rely on a service part to get data or perform a calculation. When
    part "A" relies on another part "B", you say that "A" depends on "B" and
    that "B" is a dependency of "A".

    これらの部品は他の部品に依存していることがよくあります。Angularの[コンポーネント](#component)部分は
    データを取得し計算を処理するサービス部分に依存しているかもしれません。"A" 部分が他の "B" 部分に依存しているとき、
    "A" は "B" に依存している、または "B" は "A" の依存性であるといいます。

    You can ask a "dependency injection system" to create "A"
    for us and handle all the dependencies.
    If "A" needs "B" and "B" needs "C", the system resolves that chain of dependencies
    and returns a fully prepared instance of "A".

    "依存性の注入システム" に "A" を作成させてすべての依存性を扱わせることができます。
    もし "A" が "B" を必要とし、かつ "B" が "C" を必要とするならば、
    このシステムは依存性の連鎖を解決したうえで、完全に準備された "A" を返してくれます。

    Angular provides and relies upon its own sophisticated
    [dependency injection](dependency-injection.html) system
    to assemble and run applications by "injecting" application parts
    into other application parts where and when needed.

    Angularは独自で洗練された[依存性の注入](dependency-injection.html)システムを提供し利用しています。
    必要なときに必要な場所でアプリケーションの部品を他の部品へ "注入すること" によって、アプリケーションを組み立てて実行します。

    At the core there is an [`injector`](#injector) that returns dependency values on request.
    The expression `injector.get(token)` returns the value associated with the given token.

    その中心には、要求によって依存している値を返す[`インジェクター`](#injector)があります。
    `injector.get(token)`という式は、与えられたトークンに関連する依存性の値を返します。


    A token is an Angular type (`OpaqueToken`). You rarely deal with tokens directly; most
    methods accept a class name (`Foo`) or a string ("foo") and Angular converts it
    to a token. When you write `injector.get(Foo)`, the injector returns
    the value associated with the token for the `Foo` class, typically an instance of `Foo` itself.

    トークンはAngularの型(`OpaqueToken`)です。わたしたちが直接トークンを扱うことはめったにありません。
    ほとんどのメソッドはクラス名(`Foo`)もしくは文字列("foo")を受け入れて、Angularがトークンに変換するからです。
    わたしたちが`injector.get(Foo)`と書くときには、インジェクターは`Foo`クラスのためのトークンに関連した値を返します。
    通常その値は`Foo`クラスのインスタンスそのものです。

    During many of its operations, Angular makes similar requests internally, such as when it creates a [`component`](#component) for display.

    Angularは、表示のために[`コンポーネント`](#component)を作るような処理において、似た要求を内部的にしています。

    The `Injector` maintains an internal map of tokens to dependency values.
    If the `Injector` can't find a value for a given token, it creates
    a new value using a `Provider` for that token.

    この`インジェクター`は、トークンと依存性の値とのマップを内部的に管理しています。
    もし`インジェクター`が与えられたトークンにマップされた値を見つけられないときには、そのトークンの`プロバイダー`を使って新しく値を作成します。

    A [provider](#provider) is a recipe for
    creating new instances of a dependency value associated with a particular token.

    [プロバイダー](#provider)は、特定のトークンに関連した依存性の値の新しいインスタンスを作成するためのレシピです。

    An injector can only create a value for a given token if it has
    a `provider` for that token in its internal provider registry.
    Registering providers is a critical preparatory step.

    インジェクターは、内部的なプロバイダーのレジストリの中にそのトークンのための`プロバイダー`があるときにのみ、
    依存性の値を作成することができます。
    プロバイダーをレジストリに登録しておくことは、準備段階において非常に重要なことです。

    Angular registers some of its own providers with every injector.
    We can register our own providers.

    Angularは、すべてのインジェクターにいくつか独自のプロバイダーを登録します。
    そしてわたしたちは自分のプロバイダーを登録できます。

    Read more in the [Dependency Injection](!{docsLatest}/guide/dependency-injection.html) page.

    詳しく知るには[依存性の注入](!{docsLatest}/guide/dependency-injection.html)の章を参照してください。
:marked
  ## Directive

  ## ディレクティブ (Directive)
.l-sub-section
  :marked
    An Angular class responsible for creating, reshaping, and interacting with HTML elements
    in the browser DOM. Directives are Angular's most fundamental feature.

    ブラウザのDOM内で、HTML要素を作成し変形し相互に作用することを担当する、Angularのクラスです。
    ディレクティブはAngularのもっとも基本的な機能です。

    A Directive is almost always associated with an HTML element or attribute.
    We often refer to such an element or attribute as the directive itself.
    When Angular finds a directive in an HTML template,
    it creates the matching directive class instance
    and gives the instance control over that portion of the browser DOM.

    ディレクティブはほとんどの場合HTML要素もしくは属性と連携します。
    その要素や属性をディレクティブ自身としてよく参照します。
    AngularはHTMLテンプレートの中にディレクティブを見つけると、対応するディレクティブクラスのインスタンスを作成し、
    そのインスタンスにブラウザのDOMの一部における制御を与えます。

    You can invent custom HTML markup (for example, `<my-directive>`) to
    associate with your custom directives. You add this custom markup to HTML templates
    as if you were writing native HTML. In this way, directives become extensions of
    HTML itself.

    開発者は、新しいディレクティブに紐付いたカスタムHTMLマークアップ(例えば`<my-directive>`)を作ることができます。
    そのカスタムマークアップはあたかも本来のHTMLを書くかのようにHTMLテンプレートに追加できます。
    このようにして、ディレクティブはHTML自身を拡張することになります。

    Directives fall into one of three categories:

    ディレクティブは3つの種類に分けられます：

    1. [Components](#component) that combine application logic with an HTML template to
    render application [views]. Components are usually represented as HTML elements.
    They are the building blocks of an Angular application and the
    developer can expect to write a lot of them.

    1. [コンポーネント](#component)。アプリケーションの[ビュー]をレンダリングするHTMLテンプレートと、
    アプリケーションのロジックをつなげるものです。通常、コンポーネントはHTML要素のことを指します。
    コンポーネントはAngularアプリケーションの構成要素であり、開発者によって記述されることが期待されています。

    1. [Attribute directives](#attribute-directive) that can listen to and modify the behavior of
    other HTML elements, attributes, properties, and components. They are usually represented
    as HTML attributes, hence the name.

    1. [属性ディレクティブ](#attribute-directive)。他のHTML要素、属性、プロパティ、およびコンポーネントの
    振る舞いを監視して変更することができるものです。名前からわかるように、通常、属性ディレクティブはHTML属性のことを
    指します。

    1. [Structural directives](#structural-directive), a directive responsible for
    shaping or reshaping HTML layout, typically by adding, removing, or manipulating
    elements and their children.

    1. [構造ディレクティブ](#structural-directive)。基本的には要素や子要素の追加、削除、および操作によって
    HTMLのレイアウトを成形したり再成形することを担当するディレクティブです。

.l-main-section#E

:marked
  ## ECMAScript
.l-sub-section
  :marked
    The [official JavaScript language specification](https://en.wikipedia.org/wiki/ECMAScript).

    [公式のJavaScriptの言語仕様](https://ja.wikipedia.org/wiki/ECMAScript)です。

    The latest approved version of JavaScript is
    [ECMAScript 2016](http://www.ecma-international.org/ecma-262/7.0/)
    (AKA "ES2016" or "ES7") and many Angular developers write their applications
    either in this version of the language or a dialect that strives to be
    compatible with it, such as [TypeScript](#typescript).

    JavaScriptの最新の承認されたバージョンは
    [ECMAScript 2016](http://www.ecma-international.org/ecma-262/7.0/)
    (通称"ES2016"または"ES7")であり、多くのAngular開発者はこのバージョンか、[TypeScript](#typesScript)のような、
    このバージョンの対応に取り組む言語のいずれかを使用してアプリケーションを書くでしょう。

    Most modern browsers today only support the much older "ECMAScript 5" (AKA ES5) standard.
    Applications written in ES2016, ES2015 or one of their dialects must be "[transpiled](#transpile)"
    to ES5 JavaScript.

    今日の大部分のモダンブラウザーは、それよりもずっと古い"ECMAScript 5"(通称ES5)標準しかサポートしていません。
    ES2016、 ES2015か、それらと互換性のある言語で書かれたアプリケーションは、
    ES5 JavaScriptに"[トランスパイル](#transpile)"されなければなりません。
    
    Angular developers may choose to write in ES5 directly.

    Angularアプリケーションを、ES5で直接書くこともできます。

:marked
  ## ES2015
.l-sub-section
  :marked
    Short hand for [ECMAScript](#ecmascript) 2015.
    
    "[ECMAScript 2015](#ecmascript=2015)"の簡略表現です。
:marked
  ## ES6
.l-sub-section
  :marked
    Short hand for [ECMAScript](#ecmascript) 2015.
    
    "[ECMAScript 2015](#ecmascript=2015)"の簡略表現です。
:marked
  ## ES5
.l-sub-section
  :marked
    Short hand for [ECMAScript](#ecmascript) 5, the version of JavaScript run by most modern browsers.
    See [ECMAScript](#ecmascript).

    "ECMAScript 5"の簡略表現で、ほとんどのモダンブラウザーで動くJavaScriptのバージョンです。
    [ECMAScript](#ecmascript)を参照してください。

a#F
a#G
a#H
.l-main-section#I
:marked
  ## Injector

  ## インジェクター (Injector)
.l-sub-section
  :marked
    An object in the Angular [dependency injection system](#dependency-injection)
    that can find a named "dependency" in its cache or create such a thing
    with a registered [provider](#provider).

    Angularの[依存性の注入システム](#dependency-injection)におけるオブジェクトで、
    指定された"依存性"をキャッシュから見つけるか、
    登録された[プロバイダー](#provider)を使用して生成できます。

:marked
  ## Input

  ## インプット (Input)
.l-sub-section
  :marked
    A directive property that can be the ***target*** of a
    [property binding](!{docsLatest}/guide/template-syntax.html#property-binding) (explained in detail in the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page).
    Data values flow *into* this property from the data source identified
    in the template expression to the right of the equal sign.

    [プロパティバインディング](!{docsLatest}/guide/template-syntax.html#property-binding)の
    ***対象***になるディレクティブプロパティです。
    データ値はデータソースからこのプロパティに流れ*こみます*。
    データソースはテンプレート式の中で等号の右側で識別されます。

    See the [Input and output properties](!{docsLatest}/guide/template-syntax.html#inputs-outputs) section of the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

    [テンプレート構文](!{docsLatest}/guide/template-syntax.html#inputs-outputs)の章を参照してください。

:marked
  ## Interpolation

  ## 補間（Interpolation）
.l-sub-section
  :marked
    A form of [property data binding](#data-binding) in which a
    [template expression](#template-expression) between double-curly braces
    renders as text.  That text may be concatenated with neighboring text
    before it is assigned to an element property
    or displayed between element tags, as in this example.

    [プロパティデータバインディング](#data-binding)の一形態で、その二重波括弧の間の
    [テンプレート式](#template-expression)の結果を、テキストとしてレンダリングします。
    そのテキストは、要素のプロパティに割り当てられるか、この例のように要素のタグの間で表示される前に、
    隣接したテキストに連結されることがあります。

  code-example(language="html" escape="html").
    <label>My current hero is {{hero.name}}</label>

  :marked
    Read more about [interpolation](!{docsLatest}/guide/template-syntax.html#interpolation) in the
    [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

    補間についての詳細は、
    [テンプレート構文](!{docsLatest}/guide/template-syntax.html#interpolation)の章を参照してください。

.l-main-section#J

+ifDocsFor('ts')
  a#jit
  :marked
    ## Just-in-time (JiT) compilation

    ## 実行時コンパイラ (Just-in-time (JiT) compilation)
  .l-sub-section
    :marked
      With Angular _just-in-time_  bootstrapping you compile your components and modules in the browser
      and launch the application dynamically. This is a good choice during development.
      Consider using the [ahead-of-time](#aot) mode for production apps.
      
      Angularの_実行時_ブートストラッピングでは、コンポーネントやモジュールをブラウザ上でコンパイルし、アプリケーションを動的に実行します。
      これは開発期間中においては良い選択です。
      ただし、プロダクション用のアプリケーションでは[事前コンパイラ](#aot)モードを検討してください。

.l-main-section#K
:marked
  ## kebab-case
  
  ## ケバブケース (kebab-case)
.l-sub-section
  :marked
    See [dash-case](#dash-case).
    
    [ダッシュケース](#dash-case)を参照してください。
.l-main-section#L
:marked
  ## Lifecycle hooks
  ## ライフサイクルフック (Lifecycle hooks)
.l-sub-section
  :marked
    [Directives](#directive) and [components](#component) have a lifecycle
    managed by Angular as it creates, updates, and destroys them.
    
    [ディレクティブ](#directive) と [コンポーネント](#component)は、Angularがそれらの作成、更新、破棄を管理するためのライフサイクルを持っています。

    You can tap into key moments in that lifecycle by implementing
    one or more of the lifecycle hook interfaces.

    開発者は、ひとつかそれ以上の "ライフサイクルフック" インターフェイスを実装することで、そのライフサイクル中の重要な瞬間に介入することができます。

    Each interface has a single hook method whose name is the interface name prefixed with `ng`.

    それぞれのインターフェイスは、 `ng`という接頭語でインターフェースを名前付けされた、ひとつのフックメソッドを持っています。
    
    For example, the `OnInit` interface has a hook method named `ngOnInit`.

    例えば、`OnInit`インターフェースは`ngOnInit`という名前のフックメソッドを持っています。

    Angular calls these hook methods in the following order:
    
    Angularはこれらのフック関数を次の順序で呼び出します。
    
    * `ngOnChanges` - when an [input](#input)/[output](#output) binding value changes.
    * `ngOnChanges` - [インプット](#input)/[アウトプット](#output)に紐付いている値が変わった時
    * `ngOnInit` - after the first `ngOnChanges`.
    * `ngOnInit` - 最初の`ngOnChanges`の後
    * `ngDoCheck` - developer's custom change detection.
    * `ngDoCheck` - 開発者による任意の変更検知
    * `ngAfterContentInit` - after component content initialized.
    * `ngAfterContentInit` - コンポーネントの内容を初期化後
    * `ngAfterContentChecked` - after every check of component content.
    * `ngAfterContentChecked` - コンポーネントの内容チェック後、毎回
    * `ngAfterViewInit` - after component's view(s) are initialized.
    * `ngAfterViewInit` - コンポーネントのビュー初期化後
    * `ngAfterViewChecked` - after every check of a component's view(s).
    * `ngAfterViewChecked` - コンポーネントのビューをチェック後、毎回
    * `ngOnDestroy` - just before the directive is destroyed.
    * `ngOnDestroy` - ディレクティブが破棄される直前

    Read more in the [Lifecycle Hooks](!{docsLatest}/guide/lifecycle-hooks.html) page.

    [Lifecycle Hooks](!{docsLatest}/guide/lifecycle-hooks.html)章でさらに学習することができます。
    
.l-main-section#M

:marked
  ## Module
  
  ## モジュール (Module)
.l-sub-section
  block module-defn
    .alert.is-important
      :marked
       In Angular, there are two types of modules:
       
       Angularには2種類のモジュールがあります。
       - [Angular modules](#angular-module).
       - [Angularモジュール](#angular-module)。
       For details and examples, see the [Angular Modules](!{docsLatest}/guide/ngmodule.html) page.
       
       詳細や例は[Angularモジュール](!{docsLatest}/guide/ngmodule.html)の章を参照してください。
       
       - ES2015 modules, as described in this section.
       - この節で説明するようなES2015モジュール。

    :marked
      Angular apps are modular.
      
      Angularアプリケーションはモジュール化されています。

      In general, you assemble your application from many modules, both the ones you write and the ones you acquire from others.
      
      一般的に、わたしたちのアプリケーションは自分自身で作成したもの、他から取得したものの両方からなる、多くのモジュールで組み立てられています。

      A typical module is a cohesive block of code dedicated to a single purpose.
      
      典型的なモジュールは単一の目的を満たすためのコードを凝縮したブロックです。

      A module **exports** something of value in that code, typically one thing such as a class.
      A module that needs that thing, **imports** it.
      
      モジュールは、そのコードの中で何か価値があるものを**エクスポート**します。
      それを必要とするモジュールは、それを**インポート**します。

      The structure of Angular modules and the import/export syntax
      is based on the [ES2015 module standard](http://www.2ality.com/2014/09/es6-modules-final.html).
      
      Angularのモジュール構造とimport/export構文は、[ここ](http://www.2ality.com/2014/09/es6-modules-final.html)で説明されている
      [ES2015](#es2015)モジュール標準仕様に基づいています。

      An application that adheres to this standard requires a module loader to
      load modules on request, and resolve inter-module dependencies.
      Angular does not ship with a module loader and does not have a preference
      for any particular 3rd party library (although most examples use SystemJS).
      You may pick any module library that conforms to the standard.

      この標準に準拠したアプリケーションは、リクエストに応じてモジュールをロードしたり、モジュール間の依存関係を解決するためのモジュールローダーが必要です。
      Angularはモジュールローダーを付属していませんし、特定のサードパーティ製のモジュールローダーをひいきにしていません。
      （しかし、多くのサンプルはSystemJSを利用しています。）
      アプリケーション開発者は、標準に準拠した任意のモジュールローダーを選択することができます。

      Modules are typically named after the file in which the exported thing is defined.
      The Angular [DatePipe](https://github.com/angular/angular/blob/master/modules/@angular/common/src/pipes/date_pipe.ts)
      class belongs to a feature module named `date_pipe` in the file `date_pipe.ts`.

      モジュールは慣例として、エクスポートしたものが定義されているファイルに因んで命名されます。
      Angularの[DatePipe](https://github.com/angular/angular/blob/master/modules/@angular/common/src/pipes/date_pipe.ts)クラスは、
      `date_pipe.ts`ファイルの中の`date_pipe`と名前付けられた機能モジュールに所属します。

      You rarely access Angular feature modules directly. You usually import them from one of the Angular [scoped packages](#scoped-package) such as `@angular/core`.

      開発者がAngularの機能モジュールに直接アクセスすることは、ほとんどありません。
      通常それらを`@angular/core`のような、ひとつのAngularの[スコープ化パッケージ](#scoped-package)からインポートします。

a#N
.l-main-section#O

+ifDocsFor('ts|js')
  :marked
    ## Observable
  .l-sub-section
    :marked
      You can think of an observable as an array whose items arrive asynchronously over time.
      Observables help you manage asynchronous data, such as data coming from a backend service.
      Observables are used within Angular itself, including Angular's event system and its http client service.

      Observableは、時間と共に非同期的に要素が届く配列であるとみなすことができます。
      非同期データ、たとえばバックエンドサービスから来るデータなどを扱うのに役立ちます。
      Observableは、Angularのイベントシステムやhttpクライアントサービスを含んだ、Angularの内部で使用されています。

      To use observables, Angular uses a third-party library called Reactive Extensions (RxJS).
      Observables are a proposed feature for ES 2016, the next version of JavaScript.

      Observableを使用するために、AngularはReactive Extensions (RxJS)と呼ばれているライブラリを使用しています。
      Observableは、ES 2016、すなわちJavaScriptの次期バージョンに提案されている機能です。

:marked
  ## Output

  ## アウトプット (Output)
.l-sub-section
  :marked
    A directive property that can be the ***target*** of
    [event binding](!{docsLatest}/guide/template-syntax.html#event-binding).
    Events stream *out* of this property to the receiver identified
    in the template expression to the right of the equal sign.

    [イベントバインディング](!{docsLatest}/guide/template-syntax.html#property-binding)の***対象***
    になるディレクティブプロパティです。
    イベントはこのプロパティからレシーバーに流れ*出ます*。レシーバーはテンプレート式の中で等号の右側で識別されます。

    See the [Input and output properties](!{docsLatest}/guide/template-syntax.html#inputs-outputs) section of the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

    [インプットとアウトプット](!{docsLatest}/guide/template-syntax.html#inputs-outputs)の章を参照してください。

.l-main-section#P

:marked
  ## PascalCase

  ## パスカルケース (PascalCase)
.l-sub-section
  :marked
    The practice of writing individual words, compound words, or phrases such that each word or abbreviation begins with a capital letter. Class names are typically spelled in PascalCase. Examples include: `Person` and `HeroDetailComponent`.

    複合語や句を、それぞれの単語または略語が大文字で始まるように書く方法です。
    クラス名は一般的にパスカルケースでつづられます。`Person`や`HeroDetailComponent`が例として挙げられます。

    This form is also known as **upper camel case** to distinguish it from **lower camel case**, which is simply called [camelCase](#camelcase). In this documentation, "PascalCase" means *upper camel case* and  "camelCase" means *lower camel case*.

    この形式は**アッパーキャメルケース**としても知られ、わたしたちが単に[キャメルケース](#camelcase)と呼ぶ**ロウワーキャメルケース**と区別します。
    このドキュメンテーションでは、"パスカルケース"とは*アッパーキャメルケース*のことで、"キャメルケース"とは*ロウワーキャメルケース*のことです。

:marked
  ## Pipe

  ## パイプ (Pipe)
.l-sub-section
  :marked
    An Angular pipe is a function that transforms input values to output values for
    display in a [view](#view). Use the `!{_at}Pipe` !{_decoratorLink}
    to associate the pipe function with a name. You then use that
    name in your HTML to declaratively transform values on screen.

    Angularのパイプは、入力値を[ビュー](#view)での表示のための出力値に変換する関数です。
    `!{_at}Pipe` !{_decoratorLink}を使用してpipe関数を名前と結びつけます。
    そうするとその名前をHTMLの中で、画面上の値を宣言的に変換するために使用できます。

    Here's an example that uses the built-in `currency` pipe to display
    a numeric value in the local currency.

    こちらの例では、組み込みの`currency`パイプを使用して、数値を現地通貨表示にしています。

  code-example(language="html" escape="html").
    <label>Price: </label>{{product.price | currency}}
  :marked
    Read more in the page on [pipes](!{docsLatest}/guide/pipes.html).

    詳細は、[パイプ](!{docsLatest}/guide/pipes.html)の章を参照してください。

:marked
  ## Provider

  ## プロバイダー (Provider)
.l-sub-section
  :marked
    A _provider_ creates a new instance of a dependency for the
    [dependency injection](#dependency-injection) system.
    It relates a lookup token to code&mdash;sometimes called a "recipe"&mdash;that can create a dependency value.

    [プロバイダー](!{_ProviderUrl})は[依存性の注入](#dependency-injection)システムのための、
    新しい依存性に関するインスタンスを生成します。
    プロバイダーは検索トークンを、依存性の値を作成するコード（"レシピ"と呼ばれることがあります）に紐付けます。

a#Q
.l-main-section#R

+ifDocsFor('ts|js')
  :marked
    ## Reactive forms
    ## リアクティブフォーム (Reactive forms)
  .l-sub-section
    :marked
      A technique for building Angular forms through code in a component.
      The alternate technique is [Template-Driven Forms](#template-driven-forms).

      Angularのフォームをコンポーネントのコードを通じて組み立てる技法です。
      別の技法としては[テンプレート駆動フォーム](#template-driven-forms)があります。

      When building reactive forms:

      リアクティブフォームを組み立てる際、

      - The "source of truth" is the component. The validation is defined using code in the component.
      - その"真実の情報源"はコンポーネントです。バリデーションはそのコンポーネントのコードを使用して定義されます。
      - Each control is explicitly created in the component class with `new FormControl()` or with `FormBuilder`.
      - それぞれのコントロールはそのコンポーネントのクラスにおいて、`new FormControl()`もしくは`FormBuilder`を使って明示的に生成されます。
      - The template input elements do *not* use `ngModel`.
      - そのテンプレートのinput要素は`ngModel`を使用*しません*。
      - The associated Angular directives are all prefixed with `Form` such as `FormGroup`, `FormControl`, and `FormControlName`.
      - 関連するAngularディレクティブには全て`Form`接頭辞が付けられています。たとえば、`FormGroup`、 `FormControl`、 そして`FormControlName`などです。

      Reactive forms are powerful, flexible, and great for more complex data entry form scenarios such as dynamic generation of form controls.

      リアクティブフォームは強力で柔軟なので、より複雑なデータ入力をするフォームの場合には最適です。
      たとえば、動的にフォームのコントロールを生成するような場合などです。

:marked
  ## Router

  ## ルーター (Router)
.l-sub-section
  :marked
    Most applications consist of many screens or [views](#view).
    The user navigates among them by clicking links and buttons,
    and performing other similar actions that cause the application to
    replace one view with another.

    たいていのアプリケーションは多くの画面または[ビュー](#view)から成り立ちます。
    ユーザーはリンクやボタンのクリック、そして他の類似した行為によってアプリケーションの
    ビューを別のビューに差し替えさせることで、それらの間を移動します。

    The Angular [component router](!{docsLatest}/guide/router.html) is a richly featured mechanism for configuring and managing the entire view navigation process including the creation and destruction
    of views.

    Angularの[コンポーネントルーター](!{docsLatest}/guide/router.html)は、ビューの生成と破棄を含めた、
    全てのビューの移動処理を設定し管理するための十分な機能を備えたメカニズムです。

  +ifDocsFor('ts|js')
    :marked
      In most cases, components become attached to a [router](#router) by means
      of a `RouterConfig` that defines routes to views.

      たいていの場合、コンポーネントはビューへの経路を定義した`RouterConfig`によって
      [ルーター](#router)に接続されることになります。

      A [routing component's](#routing-component) template has a `RouterOutlet` element
      where it can display views produced by the router.

      [ルーティングコンポーネント](#routing-component)のテンプレートは`RouterOutlet`要素を持ち、
      そこでルーターによって生成されたビューを表示することができます。

      Other views in the application likely have anchor tags or buttons with `RouterLink`
      directives that users can click to navigate.

      アプリケーションの中の他のビューは、ユーザーがクリックして移動することができる`RouterLink`
      ディレクティブの付いたアンカータグかボタンを持つでしょう。
      
      For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

      詳細は、[ルーティングとナビゲーション](!{docsLatest}/guide/router.html)の章を参照してください。

+ifDocsFor('ts|js')
  :marked
    ## Router module
  .l-sub-section
    :marked
      A separate [Angular module](#angular-module) that provides the necessary service providers and directives for navigating through application views.

      アプリケーションのビューの間を移動するのに必要なサービスプロバイダーおよびディレクティブを提供する、
      独立した[Angularモジュール](#angular-module)です。

      For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

      詳細は、[ルーティングとナビゲーション](!{docsLatest}/guide/router.html)の章を参照してください。

:marked
  ## Routing component
  ## ルーティングコンポーネント (Routing component)
.l-sub-section
  block routing-component-defn
    :marked
      An Angular [component](#component) with a RouterOutlet that displays views based on router navigations.

      ルーターのナビゲーションに基づきビューを表示するRouterOutletを備えたAngular [コンポーネント](#component)です。

      For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

      詳細は、[コンポーネントルーター](!{docsLatest}/guide/router.html)の章を参照してください。

.l-main-section#S

+ifDocsFor('ts|js')
  :marked
    ## Scoped package
    ## スコープ化パッケージ (Scoped package)
  .l-sub-section
    :marked
      Angular modules are delivered within *scoped packages* such as `@angular/core`, `@angular/common`, `@angular/platform-browser-dynamic`,
      `@angular/http`, and `@angular/router`.

      Angularのモジュールは、`@angular/core`、`@angular/common`、`@angular/platform-browser-dynamic`、`@angular/http`、
      および`@angular/router`のような、*スコープ化パッケージ*の範囲内で提供されます。

      A [*scoped package*](https://docs.npmjs.com/misc/scope) is a way to group related *npm* packages.

      [*スコープ化パッケージ*](https://docs.npmjs.com/misc/scope)は、関連する*npm*パッケージをグループ化する方法です。

      You import a scoped package the same way that you'd import a *normal* package.
      The only difference, from a consumer perspective,
      is that the *scoped package* name begins with the Angular *scope name*, `@angular`.

      *通常の*パッケージをインポートするのと同じ方法でスコープ化パッケージをインポートします。
      唯一の違いは、利用者の観点からは、パッケージ名は`@angular`というAngularの*スコープ名*で始まることです。

    +makeExcerpt('architecture/ts/app/app.component.ts', 'import', '')

a#snake-case
:marked
  ## snake_case

  ## スネークケース (snake_case)
.l-sub-section
  block snake-case-defn
    :marked
      The practice of writing compound words or phrases such that an
      underscore (`_`) separates one word from the next. This form is also known as **underscore case**.

      複合語や句を、それぞれの単語がひとつのアンダースコア（`_`）で隔てられるように書く方法です。
      この形式は**アンダースコアケース**としても知られています。

:marked
  ## Service

  ## サービス (Service)
.l-sub-section
  :marked
    For data or logic that is not associated
    with a specific view or that you want to share across components, build services.

    コンポーネントが重要でありすべてですが、しかし特定のビューに関連しない、またはコンポーネントを越えて共有したい
    データやロジックについてはどうするのでしょうか？ サービスを組み立てましょう！

    Applications often require services such as a hero data service or a logging service.

    アプリケーションはしばしば、ヒーローデータサービスやロギングサービスのようなサービスを必要とします。
    コンポーネントはこういった重労働をするサービスに依存します。

    A service is a class with a focused purpose.
    We often create a service to implement features that are
    independent from any specific view,
    provide shared data or logic across components, or encapsulate external interactions.

    サービスは明確な目的を持ったクラスです。
    わたしたちは、どのような特定のビューからも独立した機能や、
    コンポーネント間にわたる共有データやロジックを提供する機能、
    または外部との相互作用をカプセル化する機能を実装するために、サービスを作成することがよくあります。

    For more information, see the [Services](!{docsLatest}/tutorial/toh-pt4.html) page of the [Tour of Heroes](!{docsLatest}/tutorial/) tutorial.

    詳細は、チュートリアルの[サービス](!{docsLatest}/tutorial/toh-pt4.html)の章を参照してください。

:marked
  ## Structural directive
  ## 構造ディレクティブ (Structural directive)
.l-sub-section
  :marked
    A category of [directive](#directive) that can
    shape or reshape HTML layout, typically by adding, removing, or manipulating
    elements and their children; for example, the `ngIf` "conditional element" directive and the `ngFor` "repeater" directive.

    [ディレクティブ](#directive)の一種で、HTMLのレイアウトを成形または再成形することができます。
    典型的には要素とその子孫を追加、除去、または操作することにより行います。
    `ngIf`"条件要素"ディレクティブと、`ngFor`"繰り返し"ディレクティブはこの類の良い例です。

    Read more in the [Structural Directives](!{docsLatest}/guide/structural-directives.html) page.

    詳細は、[構造ディレクティブ](!{docsLatest}/guide/structural-directives.html)の章を参照してください。

.l-main-section#T
:marked
  ## Template

  ## テンプレート (Template)
.l-sub-section
  :marked
    A template is a chunk of HTML that Angular uses to render a [view](#view) with
    the support and continuing guidance of an Angular [directive](#directive),
    most notably a [component](#component).

    テンプレートは、ディレクティブ、特にコンポーネントによるサポートと一連の指示をもってビューを描画するために、
    Angularが使用するHTMLの塊です。

+ifDocsFor('ts|js')
  :marked
    ## Template-driven forms
    ## テンプレート駆動フォーム (Template-driven forms)
  .l-sub-section
    :marked
      A technique for building Angular forms using HTML forms and input elements in the view.
      The alternate technique is [Reactive Forms](#reactive-forms).

      ビューにおいてHTMLのフォームとinput要素を使用してAngularのフォームを組み立てる技法です。
      別の技法としては[リアクティブフォーム](#reactive-forms)があります。

      When building template-driven forms:

      テンプレート駆動フォームを組み立てる際、

      - The "source of truth" is the template. The validation is defined using attributes on the individual input elements.
      - "真実の情報源"はテンプレートです。バリデーションは個々のinput要素の属性を使用して定義されます。
      - [Two-way binding](#data-binding) with `ngModel` keeps the component model in synchronization with the user's entry into the input elements.
      - `ngModel`を用いた[双方向バインディング](#data-binding)が、コンポーネントのモデルとユーザーによるinput要素への入力との同期を維持します。
      - Behind the scenes, Angular creates a new control for each input element, provided you have set up a `name` attribute and two-way binding for each input.
      - 舞台裏では、Angularは`name`属性および双方向バインディングの設定を持つ各input要素のために、新しいコントロールを生成します。
      - The associated Angular directives are all prefixed with `ng` such as `ngForm`, `ngModel`, and `ngModelGroup`.
      - 関連するAngularディレクティブには全て`ng`接頭辞が付けられています。たとえば、`ngForm`、`ngModel`、そして`ngModelGroup`などです。

      Template-driven forms are convenient, quick, and simple. They are a good choice for many basic data entry form scenarios.

      テンプレート駆動フォームは便利で短時間で作成でき、そして単純なので、多数の基本的なデータ入力をするフォームの場合には良い選択です。

      Read about how to build template-driven forms
      in the [Forms](!{docsLatest}/guide/forms.html) page.

      テンプレート駆動フォームを組み立てる方法の詳細は、
      [フォーム](!{docsLatest}/guide/forms.html)の章を参照してください。

:marked
  ## Template expression
  ## テンプレート式 (Template expression)
.l-sub-section
  :marked
    An expression is a !{_Lang}-like syntax that Angular evaluates within
    a [data binding](#data-binding).

    Read about how to write template expressions
    in the [Template Syntax](!{docsLatest}/guide/template-syntax.html#template-expressions) page.

    テンプレート式は、Angularが[データバインディング](#data-binding)の内部で評価する
    !{_Lang}に似た構文です。テンプレート式を記述する方法の詳細は、
    [テンプレート構文](!{docsLatest}/guide/template-syntax.html#template-expressions)の章を参照してください。

:marked
  ## Transpile

  ## トランスパイル (Transpile)
.l-sub-section
  :marked
    The process of transforming code written in one form of JavaScript
    (for example, TypeScript) into another form of JavaScript  (for example, [ES5](#es5)).

    あるJavaScriptについての形式で書かれたコード（たとえば、TypeScript）を、
    別のJavaScriptについての形式（たとえば、[ES5](#es5)）に変換する処理のことです。

 :marked
  ## TypeScript
.l-sub-section
  :marked
    A version of JavaScript that supports most [ECMAScript 2015](#ecmascript=2015)
    language features such as [decorators](#decorator).

    大部分の[ECMAScript 2015](#ecmascript=2015)の言語機能、および[デコレーター](#decorator)のような
    JavaScriptの将来のバージョンにておそらく到来するであろう機能をサポートしたJavaScriptのバージョンです。

    TypeScript is also noteable for its optional typing system, which gives
    us compile-time type checking and strong tooling support (for example, "intellisense",
    code completion, refactoring, and intelligent search). Many code editors
    and IDEs support TypeScript either natively or with plugins.
    
    TypeScriptはそのオプショナルな型システムについても注目に値します。
    それはコンパイル時の型検査と強力なツールのサポート（たとえば、"インテリセンス"、
    コード補完、リファクタリング、インテリジェントな検索）を提供するものです。
    多くのコードエディターとIDEはTypeScriptをネイティブに、またはプラグインを用いてサポートします。

    TypeScript is the preferred language for Angular development although
    you can use other JavaScript dialects such as [ES5](#es5).
    
    TypeScriptはAngualrの開発において推奨される言語ですが、
    [ES5](#es5)のような他のJavaScriptの言語で書くことも歓迎します。

    Read more about TypeScript at [typescript.org](http://www.typescriptlang.org/).

    TypeScriptについての詳細は、その[ウェブサイト](http://www.typescriptlang.org/)を参照してください。

a#U
.l-main-section#V

:marked
  ## View

  ## ビュー (View)
.l-sub-section
  :marked
    A view is a portion of the screen that displays information and responds
    to user actions such as clicks, mouse moves, and keystrokes.

    ビューは画面の一部分です。情報を表示し、そしてクリック、マウス移動、キーストロークのような
    ユーザーのアクションに反応します。

    Angular renders a view under the control of one or more [directives](#directive),
    especially  [component](#component) directives and their companion [templates](#template).
    The component plays such a prominent role that it's often
    convenient to refer to a component as a view.

    Angularはひとつ以上の[ディレクティブ](#directive)、特に、[コンポーネント](#component)ディレクティブと
    それらに対を成す[テンプレート](#template)の制御下でビューを描画します。
    コンポーネントはそのような、コンポーネントをビューと呼ぶのが都合がいいと感じるほどの重要な役割を担っています。

    Views often contain other views and any view might be loaded and unloaded
    dynamically as the user navigates through the application, typically
    under the control of a [router](#router).

    ビューは他のビューを含むことがよくあり、あらゆるビューは動的に読み込まれたり取り出されたりするかもしれません。
    典型的には[ルーター](#router)の制御下で、ユーザーがアプリケーション内を移動することで行われます。

a#W
a#X
a#Y
.l-main-section#Z

:marked
  ## Zone
.l-sub-section
  block zone-defn
    :marked
      Zones are a mechanism for encapsulating and intercepting
      a JavaScript application's asynchronous activity.

      Zoneは、JavaScriptアプリケーションの非同期動作をカプセル化して横取りする仕組みです。

      The browser DOM and JavaScript have a limited number
      of asynchronous activities, activities such as DOM events (for example, clicks),
      [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), and
      [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
      calls to remote servers.

      ブラウザーのDOMとJavaScriptが持つ非同期動作の数は限られています。たとえば（クリック等の）DOMイベント、
      [Promise](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise)、そして
      リモートサーバーへの[XHR](https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest)コールなどです。

      Zones intercept all of these activities and give a "zone client" the opportunity
      to take action before and after the async activity finishes.

      Zoneはこれらの全ての動作を横取りし、"Zoneクライアント"に、
      その非同期動作の前と完了後に操作を行う機会を与えます。

      Angular runs your application in a zone where it can respond to
      asynchronous events by checking for data changes, and updating
      the information it displays via [data bindings](#data-binding).

      AngularはアプリケーションをZoneの中で実行します。
      その中でAngularは非同期イベントに反応することができ、データの変更を検査し、
      [データバインディング](#data-binding)によって表示する情報を更新します。

      Learn more about zones in this
      [Brian Ford video](https://www.youtube.com/watch?v=3IqtmUscE_U).

      Zoneについての詳細は、この
      [Brian Fordのビデオ](https://www.youtube.com/watch?v=3IqtmUscE_U)を参照してください。
