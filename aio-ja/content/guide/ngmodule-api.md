# NgModule API

#### 前提条件

次の基本的な理解:
* [ブートストラップ](guide/bootstrapping)
* [JavaScriptモジュールとNgModule](guide/ngmodule-vs-jsmodule)

<hr />

## `@NgModule`の目的

大まかに言うと、
NgModuleはAngularアプリケーションを整理する方法で、
`@NgModule`デコレーター内のメタデータを通して実現します。
メタデータは3つのカテゴリに分類されます:

* **静的:** コンパイラーの設定。ディレクティブのセレクターと、テンプレート内のディレクティブがセレクターのマッチングを通してどれに適用すべきかをコンパイラーに知らせます。これは`declarations`配列によって設定されます。
* **ランタイム:** `providers`配列経由でのインジェクターの設定。
* **コンポーザビリティ/グルーピング:** `imports`、`exports`配列経由でNgModuleをまとめたり、利用可能にします。

```typescript
@NgModule({
  // 静的, つまりコンパイラーの設定です
  declarations: [], // セレクターを設定します
  entryComponents: [], // ホストファクトリーを生成します

  // ランタイム, またはインジェクターの設定
  providers: [], // ランタイムインジェクター設定

  // コンポーザビリティ / グルーピング
  imports: [], // NgModuleを合成します
  exports: [] // NgModuleをアプリケーションの他の部分で利用可能にします
})
```

## `@NgModule` メタデータ

次の表は`@NgModule`メタデータのプロパティをまとめたものです。

<table>

  <tr>

    <th>
      プロパティ
    </th>

    <th>
      説明
    </th>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>declarations</code>
    </td>

    <td>

      _このモジュールに属している_[宣言](guide/ngmodule-faq#q-declarable)クラス
      (*コンポーネント*、*ディレクティブ*、*パイプ*)のリスト。

      <ol>
        <li>テンプレートをコンパイルするときは、対応するディレクティブを動作させるために使用するセレクターのセットを決定する必要があります。</li>
        <li>
          テンプレートは、NgModule&mdash;テンプレートのコンポーネントが宣言されているNgModule&mdash;のコンテキスト内でコンパイルされます。セレクターのセットは次のルールで決定されます:
          <ul>
            <li>すべての<code>declarations</code>配列内のディレクティブのセレクター</li>
            <li>すべてのインポートしたNgModuleがエクスポートしているディレクティブのセレクター</li>
          </ul>
        </li>
      </ol>

      コンポーネント、ディレクティブ、およびパイプは、_厳密_に1つのモジュールに属している必要があります。
      複数のモジュールで同じクラスを宣言しようとすると、コンパイラでエラーが発生します。

      他のモジュールからインポートしたクラスを再び宣言してはいけません。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>providers</code>
    </td>

    <td>

      依存性の注入のプロバイダーのリスト。

      AngularはNgModuleのインジェクターを使用してこれらのプロバイダーを登録します。
      それがブートストラップに使用されているNgModuleの場合は、ルートインジェクターに登録されます。

      これらのサービスはこのインジェクターの子供である任意のコンポーネント、ディレクティブ、パイプ、またはサービスに注入できるようになります。

      遅延ロードしたモジュールは、
      通常はアプリケーションのルートインジェクターの子供となる自分自身のインジェクターを持ちます。

      遅延ロードしたサービスは遅延ロードモジュールのインジェクターにスコープされます。
      遅延ロードしたモジュールが`UserService`を提供していた場合、
      そのモジュールのコンテキスト(たとえばルーターのナビゲーションによって)で作成された任意のコンポーネントはルートインジェクター内のインスタンスではなく、
      サービスのローカルインスタンスを取得します。

      外部モジュール内のコンポーネントはそれぞれのインジェクターが提供するインスタンスを受け取り続けます。

      注入の階層やスコーピングの詳細については[プロバイダー](guide/providers)を参照してください。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>imports</code>
    </td>

    <td>

      このモジュールに畳み込まれるべきモジュールのリスト。
      畳み込むとは、すべてのインポートされたNgModuleのエクポートされたプロパティがあたかもここで宣言されたかのようにするという意味です。

      具体的には、
      エクスポートされたコンポーネント、ディレクティブ、またはパイプを持つモジュールのリストがこのモジュールで宣言されたかのようにコンポーネントのテンプレートから参照されます。

      参照がこのモジュールで宣言されている、
      もしくはインポートしたモジュールがエクスポートしている場合に、
      コンポーネントのテンプレートは他のコンポーネント、ディレクティブ、およびパイプを[参照](guide/ngmodule-faq#q-template-reference)することができます。
      たとえば、コンポーネントはモジュールがAngularの`CommonModule`をインポートするだけ(おそらく`BrowserModule`をインポートすることで間接的にインポートされます)で`NgIf`や`NgFor`ディレクティブを使用することができます。

      多くの標準ディレクティブを`CommonModule`からインポートすることができます。
      しかし、いくつかのおなじみのディレクティブは他のモジュールに属しています。
      たとえば、
      Angularの`FormsModule`をインポートしたあとにのみ`[(ngModel)]`を使用することができます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>exports</code>
    </td>

    <td>

      インポートするモジュールが使用することができる宣言のリスト
      &mdash;*コンポーネント*、*ディレクティブ*、および*パイプ* クラス&mdash;。

      エクスポートされた宣言はモジュールの_公開API_となります。
      他のモジュール内のコンポーネントは、このモジュールをインポートしていて、かつ`UserComponent`をエクスポートしている場合、
      _この_モジュールの`UserComponent`を[使用](guide/ngmodule-faq#q-template-reference)することができます。

      宣言はデフォルトでは非公開です。
      このモジュールが`UserComponent`をエクスポート_しない_場合
      _この_モジュールのコンポーネントだけが`UserComponent`を使用することができます。

      モジュールをインポートしてもインポートされたモジュールのインポートを自動的に再エクスポート_しません_。
      モジュール'B'は`CommonModule`をインポートしているモジュール'A'をインポートしただけでは`ngIf`を使用することはできません。
      モジュール'B'は`CommonModule`を自分自身でインポートする必要があります。

      モジュールは他のモジュールを自身の`exports`配列に追加することができます。
      その場合、そのモジュールの公開されているコンポーネント、ディレクティブ、パイプすべてがエクスポートされます。

      [再エクスポート](guide/ngmodule-faq#q-reexport)はモジュールの推移性を明示的にします。
      モジュール'A'が`CommonModule`を再エクスポートしてモジュール'B'がモジュール'A'をインポートした場合、
      モジュール'B'のコンポーネントはモジュール'B'自身が`CommonModule`をインポートしなくても`ngIf`を使用することができます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>bootstrap</code>
    </td>

    <td>

      自動でブートストラップされるコンポーネントのリスト。

      通常、このリストにはアプリケーションの_ルートコンポーネント_1つだけが配置されます

      Angularは複数のブートストラップコンポーネントを使用して起動できます
      それぞれ各自のホストウェブページ内のロケーションに。

      ブートストラップコンポーネントは自動的に`entryComponents`に追加されます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>entryComponents</code>
    </td>

    <td>

      ビューに動的にロードすることができるコンポーネントのリスト。

      デフォルトでは、Angularアプリケーションは常に少なくとも1つのエントリーコンポーネントを持ちます(ルートコンポーネントである`AppComponent`)。その目的はアプリケーションへのエントリーポイントとしてサーブすることです。アプリケーションを起動するためにブートストラップします。

      ルーテッドコンポーネントも動的にロードする必要があるため、_エントリーコンポーネント_です。
      ルーターはそれらを生成して、`<router-outlet>`付近のDOMにドロップします。

      ブートストラップするコンポーネントとルーテッドコンポーネントは_エントリーコンポーネント_ですが、
      これは暗黙的に追加されるので`entryComponents`配列に追加する必要はありません。

      Angularはモジュールの`bootstrap`とルート定義内のコンポーネントを`entryComponents`配列に自動的に追加します。

      たとえば、[`ViewComponentRef.createComponent()`]で生成されるような、ブートストラップされたコンポーネントから発見できないものだけに必要な技術です。ｘ必須の技術の1つを使用してブートストラップされたコンポーネントだけが残ります。

      動的なコンポーネントのロードはルーターを超えるほとんどのアプリケーションで一般的ではありません。動的にコンポーネントをロードしたい場合は、`entryComponents`配列に手動でコンポーネントを追加する必要があります。

      詳細については[Entry Components](guide/entry-components)を参照してください。

    </td>

  </tr>

</table>


<hr />

## NgModuleの詳細

あなたはこちらにも興味があるかもしれません:
* [フィーチャーモジュール]](guide/feature-modules)
* [エントリーコンポーネント](guide/entry-components)
* [プロバイダー](guide/providers)
* [フィーチャーモジュールの種類](guide/module-types)
