# NgModule API

大まかにいうと、
NgModuleはAngularアプリケーションを整理する方法で、
`@NgModule`デコレーター内のメタデータを通して実現します。
メタデータは3つのカテゴリーに分類されます:

* **静的:** コンパイラーの設定。ディレクティブのセレクターと、テンプレート内のディレクティブがセレクターのマッチングを通してどれに適用すべきかをコンパイラーに知らせます。これは`declarations`配列によって設定されます。
* **ランタイム:** `providers`配列経由でのインジェクターの設定。
* **コンポーザビリティ/グルーピング:** `imports`、`exports`配列経由でNgModuleをまとめて、利用可能にします。

```typescript
@NgModule({
  // 静的な、つまりコンパイラーの設定です
  declarations: [], // セレクターを設定します
  entryComponents: [], // ホストファクトリーを生成します

  // ランタイム、あるいはインジェクターの設定
  providers: [], // ランタイムインジェクター設定

  // コンポーザビリティ / グルーピング
  imports: [], // NgModuleをまとめて組み込みます
  exports: [] // NgModuleをアプリケーションの他の部分で利用可能にします
})
```

## `@NgModule` メタデータ

次の表は`@NgModule`メタデータのプロパティをまとめたものです。

<table>

  <tr>

    <th>
      プロパティ
    </th>

    <th>
      説明
    </th>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>declarations</code>
    </td>

    <td>

      _このモジュールに属している_[宣言](guide/ngmodule-faq#q-declarable)クラス
      (*コンポーネント*、*ディレクティブ*、および*パイプ*)のリスト。

      <ol>
        <li>テンプレートをコンパイルするときは、対応するディレクティブを動作させるために使用するセレクターのセットを決定する必要があります。</li>
        <li>
          テンプレートは、テンプレートのコンポーネントが宣言されているNgModuleのコンテキスト内でコンパイルされます。セレクターのセットは次のルールで決定されます:
          <ul>
            <li>すべての<code>declarations</code>配列内のディレクティブのセレクター</li>
            <li>すべてのインポートしたNgModuleがエクスポートしているディレクティブのセレクター</li>
          </ul>
        </li>
      </ol>

      コンポーネント、ディレクティブ、およびパイプは、_厳密_に1つのモジュールに属している必要があります。
      複数のモジュールで同じクラスを宣言しようとすると、コンパイラでエラーが発生します。
      別のモジュールから直接的または間接的にインポートされたクラスを再宣言しないように注意してください。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>providers</code>
    </td>

    <td>

      依存性の注入のプロバイダーのリスト。

      AngularはNgModuleのインジェクターを使用してこれらのプロバイダーを登録します。
      それがブートストラップに使用されているNgModuleの場合は、ルートインジェクターに登録されます。

      これらのサービスはこのインジェクターの子供である任意のコンポーネント、ディレクティブ、パイプ、またはサービスに注入できるようになります。

      遅延ロードしたモジュールは、
      通常はアプリケーションのルートインジェクターの子供である自身のインジェクターを持ちます。

      遅延ロードしたサービスは遅延ロードしたモジュールのインジェクターのスコープで管理されます。
      遅延ロードしたモジュールが`UserService`を提供していた場合、
      そのモジュールのコンテキスト(たとえばルーターのナビゲーションによって)で作成した任意のコンポーネントはルートインジェクター内のインスタンスではなく、
      サービスのローカルインスタンスを取得します。

      外部モジュール内のコンポーネントはそれぞれのインジェクターが提供するインスタンスを受け取り続けます。

      注入の階層やスコーピングの詳細については[プロバイダー](guide/providers)や[DIガイド](guide/dependency-injection)を参照してください。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>imports</code>
    </td>

    <td>

      このモジュールに畳み込まれるべきモジュールのリスト。
      畳み込むとは、すべてのインポートしたNgModuleがエクポートしているプロパティがあたかもここで宣言したかのようにするという意味です。

      具体的には、
      コンポーネント、ディレクティブ、またはパイプをエクスポートしているモジュールのリストが、このモジュールで宣言したかのようにコンポーネントのテンプレートから参照されます。

      コンポーネントのテンプレートが他のコンポーネント、ディレクティブ、およびパイプを[参照](guide/ngmodule-faq#q-template-reference)することができるのは、
その参照がこのモジュールで宣言されているか、もしくはインポートしたモジュールがエクスポートしているときです。
      たとえば、コンポーネントはモジュールがAngularの`CommonModule`をインポートするだけ(おそらく`BrowserModule`をインポートすることで間接的にインポートされます)で`NgIf`や`NgFor`ディレクティブを使用することができます。

      多くの標準ディレクティブを`CommonModule`からインポートすることができます。
      しかし、いくつかのおなじみのディレクティブは他のモジュールに属しています。
      たとえば、
      Angularの`FormsModule`をインポートしたあとにのみ`[(ngModel)]`を使用することができます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>exports</code>
    </td>

    <td>

      インポートするモジュールが使用することができる宣言
      (*コンポーネント*、*ディレクティブ*、および*パイプ* クラス)のリスト。

      エクスポートした宣言はモジュールの_公開API_となります。
      他のモジュール内のコンポーネントは、このモジュールをインポートしていて、かつ`UserComponent`をエクスポートしている場合、
      _この_モジュールの`UserComponent`を[使用](guide/ngmodule-faq#q-template-reference)することができます。

      宣言はデフォルトでは非公開です。
      このモジュールが`UserComponent`をエクスポート_しない_場合
      _この_モジュール内のコンポーネントだけが`UserComponent`を使用することができます。

      モジュールをインポートしても、インポートしたモジュールのインポートを自動的に再エクスポート_しません_。
      モジュール'B'は`CommonModule`をインポートしているモジュール'A'をインポートしただけでは`ngIf`を使用することはできません。
      モジュール'B'は`CommonModule`を自分自身でインポートする必要があります。

      モジュールは他のモジュールを自身の`exports`配列に追加することができます。
      その場合、そのモジュールの公開されているコンポーネント、ディレクティブ、およびパイプすべてがエクスポートされます。

      [再エクスポート](guide/ngmodule-faq#q-reexport)はモジュールの推移性を明示的にします。
      モジュール'A'が`CommonModule`を再エクスポートしていてモジュール'B'がモジュール'A'をインポートした場合、
      モジュール'B'のコンポーネントはモジュール'B'自身が`CommonModule`をインポートしていなくても`ngIf`を使用することができます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>bootstrap</code>
    </td>

    <td>

      自動でブートストラップされるコンポーネントのリスト。

      通常、このリストにはアプリケーションの _ルートコンポーネント_ 1つだけが配置されます

      Angularは複数のブートストラップコンポーネント
      (ホストウェブページ内のそれぞれ自身のコンポーネントが配置された場所)で起動できます。

      ブートストラップコンポーネントは自動的に`entryComponents`に追加されます。

    </td>

  </tr>

  <tr>

    <td style="vertical-align: top">
      <code>entryComponents</code>
    </td>

    <td>

      ビューに動的にロードすることができるコンポーネントのリスト。

      デフォルトでは、Angularアプリケーションは常に少なくとも1つのエントリーコンポーネントを持ちます(ルートコンポーネントである`AppComponent`)。その目的はアプリケーションへのエントリーポイントとして機能することで、つまり、アプリケーションを起動するためにそれをブートストラップします。

      ルーテッドコンポーネントも動的にロードする必要があるため、_エントリーコンポーネント_になります。
      ルーターはそれを生成して、`<router-outlet>`付近のDOMに配置します。

      ブートストラップするコンポーネントとルーテッドコンポーネントは_エントリーコンポーネント_ですが、
      これは暗黙的に追加されるので
      `entryComponents`配列に追加する必要はありません。

      Angularはモジュールの`bootstrap`とルート定義内のコンポーネントを`entryComponents`配列に自動的に追加します。

      たとえば、[`ViewComponentRef.createComponent()`](https://angular.io/api/core/ViewContainerRef#createComponent)で生成されるような、ブートストラップしたコンポーネントから発見できないものだけに必要な技術です。

      動的なコンポーネントのロードはルーター以外のほとんどのアプリケーションで一般的ではありません。動的にコンポーネントをロードしたい場合は、`entryComponents`配列に手動でコンポーネントを追加する必要があります。

      詳細については[エントリーコンポーネント](guide/entry-components)を参照してください。

    </td>

  </tr>

</table>


<hr />

## NgModuleの詳細

あなたはこちらにも興味があるかもしれません:
* [フィーチャーモジュール](guide/feature-modules)
* [エントリーコンポーネント](guide/entry-components)
* [プロバイダー](guide/providers)
* [フィーチャーモジュールの種類](guide/module-types)
